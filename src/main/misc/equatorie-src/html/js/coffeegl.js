;(function(e,t,n){function r(n,i){if(!t[n]){if(!e[n]){var s=typeof require=="function"&&require;if(!i&&s)return s(n,!0);throw new Error("Cannot find module '"+n+"'")}var o=t[n]={exports:{}};e[n][0](function(t){var i=e[n][1][t];return r(i?i:t)},o,o.exports)}return t[n].exports}for(var i=0;i<n.length;i++)r(n[i]);return r})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/
* https://github.com/field/FieldKit.js

- TODO
* Need a shorthand here for sure!
*/


/* CoffeeGL entry point
*/


(function() {
  var CoffeeGL, GL, extend, util, _setupFrame;

  CoffeeGL = {};

  GL = {};

  util = require('./util');

  extend = function() {
    var pkg;
    switch (arguments.length) {
      case 1:
        return util.extend(CoffeeGL, arguments[0]);
      case 2:
        pkg = arguments[0];
        if (CoffeeGL[pkg] == null) {
          CoffeeGL[pkg] = {};
        }
        return util.extend(CoffeeGL[pkg], arguments[1]);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.CoffeeGL = CoffeeGL;
  }

  if (typeof window !== "undefined" && window !== null) {
    window.GL = GL;
  }

  extend(require('./app'));

  extend(require('./math'));

  extend("Colour", require('./colour'));

  extend(require('./primitives'));

  extend(require('./node'));

  extend(require('./model'));

  extend(require('./shader'));

  extend(require('./request'));

  extend(require('./fbo'));

  extend(require('./texture'));

  extend("Camera", require('./camera'));

  extend("Shapes", require('./shapes'));

  extend(require('./webgl'));

  extend(require('./util'));

  extend(require('./signal'));

  extend("Light", require('./light'));

  extend(require('./material'));

  extend(require('./error'));

  extend(require('./functions'));

  extend(require('./animation'));

  _setupFrame = function(root) {
    var onEachFrame;
    if (root.webkitRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return webkitRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else if (root.mozRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return mozRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else {
      onEachFrame = function(cb) {
        return setInterval(cb, 1000 / 60);
      };
    }
    return root.onEachFrame = onEachFrame;
  };

  if (typeof window !== "undefined" && window !== null) {
    _setupFrame(window);
  }

  module.exports = {
    CoffeeGL: CoffeeGL,
    GL: GL
  };

}).call(this);

},{"./util":2,"./math":3,"./app":4,"./colour":5,"./primitives":6,"./node":7,"./model":8,"./shader":9,"./request":10,"./fbo":11,"./texture":12,"./camera":13,"./shapes":14,"./webgl":15,"./signal":16,"./light":17,"./material":18,"./error":19,"./functions":20,"./animation":21}],2:[function(require,module,exports){
(function(){// Generated by CoffeeScript 1.6.1
(function() {
  var util;

  util = {};

  util.extend = function(obj, source) {
    var i, il, keys, prop, safeHasOwnProperty;
    if (Object.keys) {
      keys = Object.keys(source);
      i = 0;
      il = keys.length;
      while (i < il) {
        prop = keys[i];
        Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));
        i++;
      }
    } else {
      safeHasOwnProperty = {}.hasOwnProperty;
      for (prop in source) {
        if (safeHasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  util.removeElement = function(element, list) {
    var index;
    index = list.indexOf(element);
    if (index !== -1) {
      list.splice(index, 1);
    }
    return list;
  };

  util.clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    if (obj instanceof Float32Array) {
      return new Float32Array(obj);
    }
    if (obj instanceof Uint16Array) {
      return new Uint16Array(obj);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = util.clone(obj[key]);
    }
    return newInstance;
  };

  module.exports = util;

}).call(this);

})()
},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


TODO - byte vs float - convert when sent to the shader and allow specification any way
*/


/* RGBA
*/


(function() {
  var RGB, RGBA;

  RGBA = (function() {

    function RGBA(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

    RGBA.prototype.flatten = function() {
      return [this.r, this.g, this.b, this.a];
    };

    RGBA.WHITE = function() {
      return new RGBA(1.0, 1.0, 1.0, 1.0);
    };

    return RGBA;

  })();

  /* RGB
  */


  RGB = (function() {

    function RGB(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    RGB.prototype.flatten = function() {
      return [this.r, this.g, this.b];
    };

    RGB.WHITE = function() {
      return new RGB(1.0, 1.0, 1.0);
    };

    return RGB;

  })();

  module.exports = {
    RGBA: RGBA,
    RGB: RGB
  };

}).call(this);

},{}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


Error Handling code

- TODO 
  * Line numbers maybe?
  * Problem with using @ as we are including this file in many places with node :S
*/


(function() {
  var CoffeeGLDebug, CoffeeGLError, CoffeeGLLog, CoffeeGLWarning, CoffeeGLWarningOnce, cache,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  cache = [];

  /* CoffeeGLError
  */


  CoffeeGLError = function(msg, obj) {
    var f;
    f = "CoffeeGL Error : " + msg;
    if (obj != null) {
      f += " in " + obj;
    }
    console.error(f);
    throw f;
  };

  /* CoffeeGLWarning
  */


  CoffeeGLWarning = function(msg, obj) {
    var f;
    f = "CoffeeGL Warning : " + msg;
    if (obj != null) {
      f += " in " + obj;
    }
    return console.warn(f);
  };

  /* CoffeeGLWarningOnce
  */


  CoffeeGLWarningOnce = function(msg, obj) {
    var f, result;
    result = __indexOf.call(cache, msg) >= 0;
    if (!result) {
      f = "CoffeeGL Warning : " + msg;
      if (obj != null) {
        f += " in " + obj;
      }
      console.warn(f);
      return cache.push(msg);
    }
  };

  /* CoffeeGLDebug
  */


  CoffeeGLDebug = function(msg, obj) {
    var f;
    if (CoffeeGL.Context.debug) {
      f = "CoffeeGL Debug : " + msg;
      if (obj != null) {
        f += " in " + obj;
      }
      return console.log(f);
    }
  };

  /* CoffeeGLLog
  */


  CoffeeGLLog = function(msg, obj) {
    var f;
    f = "CoffeeGL Log : " + msg;
    if (obj != null) {
      f += " in " + obj;
    }
    return console.log(f);
  };

  module.exports = {
    CoffeeGLError: CoffeeGLError,
    CoffeeGLWarning: CoffeeGLWarning,
    CoffeeGLLog: CoffeeGLLog,
    CoffeeGLWarningOnce: CoffeeGLWarningOnce,
    CoffeeGLDebug: CoffeeGLDebug
  };

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


http://www.flipcode.com/documents/matrfaq.html

  - Thanks: Tojiro - https://github.com/toji/gl-matrix
  - Thanks: Cinder for most of the math!


- TODO
  * Matrix mult function for vectors as well as scalars and matrices
  * Make functions that multiply other things destructive
  * We have set/getPos on the matrices but should we have rotation as well?
*/


(function() {
  var CoffeeGLWarning, EPSILON_VALUE, Matrix2, Matrix3, Matrix4, PI, Quaternion, Vec2, Vec3, Vec4, degToRad, glMatrixArrayType, precomputeTangent, radToDeg, rayPlaneIntersect, _precomputeTangent;

  CoffeeGLWarning = require('./error').CoffeeGLWarning;

  if (typeof (typeof Float32Array !== "undefined" && Float32Array !== null)) {
    glMatrixArrayType = Float32Array;
  } else if (typeof (typeof WebGLFloatArray !== "undefined" && WebGLFloatArray !== null)) {
    glMatrixArrayType = WebGLFloatArray;
  } else {
    glMatrixArrayType = Array;
  }

  EPSILON_VALUE = 4.37114e-05;

  PI = 3.14159;

  ({
    sinx_over_x: function(x) {
      if (x * x < 1.19209290e-07) {
        return 1;
      } else {
        return Math.sin(x) / x;
      }
    }
  });

  radToDeg = function(a) {
    return a * 57.2957795;
  };

  degToRad = function(a) {
    return a * 0.017453292523928;
  };

  /* rayPlaneIntersect
  */


  rayPlaneIntersect = function(plane_point, plane_normal, line_point, line_dir) {
    var den, num;
    num = Vec3.dot(plane_normal, Vec3.sub(plane_point, line_point));
    den = Vec3.dot(plane_normal, line_dir);
    return num / den;
  };

  /* precomputeTangent
  */


  precomputeTangent = function(a, b, c, na, nb, nc, ta, tb, tc) {
    return [_precomputeTangent(a, b, c, na, ta, tb, tc), _precomputeTangent(b, c, a, nb, tb, tc, ta), _precomputeTangent(c, a, b, nc, tc, ta, tb)];
  };

  _precomputeTangent = function(a, b, c, n, ta, tb, tc) {
    var alpha, binormal, binormal2, d, e, f, g, tangent, tx, ty, tz, ux, uy, uz;
    d = Vec3.sub(b, a);
    e = Vec3.sub(c, a);
    f = Vec2.sub(tb, ta);
    g = Vec2.sub(tc, ta);
    alpha = 1 / ((f.x * g.y) - (f.y * g.x));
    tx = alpha * (g.y * d.x + -f.y * e.x);
    ty = alpha * (g.y * d.y + -f.y * e.y);
    tz = alpha * (g.y * d.z + -f.y * e.z);
    ux = alpha * (-g.x * d.x + f.x * e.x);
    uy = alpha * (-g.x * d.y + f.x * e.y);
    uz = alpha * (-g.x * d.z + f.x * e.z);
    tangent = new Vec3(tx, ty, tz);
    binormal = new Vec3(ux, uy, uz);
    tangent = tangent.sub(Vec3.multScalar(n, Vec3.dot(n, tangent)));
    binormal2 = binormal.sub(Vec3.multScalar(n, Vec3.dot(n, binormal)));
    binormal2 = binormal2.sub(Vec3.multScalar(tangent, Vec3.dot(tangent, binormal)));
    tangent.normalize();
    binormal2.normalize();
    return tangent;
  };

  /*Vec2
  */


  Vec2 = (function() {

    Vec2.prototype._DIM = 2;

    Vec2.sub = function(a, b) {
      return a.copy()["sub"](b);
    };

    Vec2.add = function(a, b) {
      return a.copy()["add"](b);
    };

    Vec2.div = function(a, b) {
      return a.copy()["div"](b);
    };

    Vec2.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Vec2.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Vec2.normalize = function(a) {
      return a.copy()["normalize"]();
    };

    Vec2.dot = function(a, b) {
      return a.dot(b);
    };

    function Vec2(x, y) {
      var _ref;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      _ref = [x, y], this.x = _ref[0], this.y = _ref[1];
    }

    Vec2.prototype.copy = function() {
      return new Vec2(this.x, this.y);
    };

    Vec2.prototype.copyFrom = function(a) {
      this.x = a.x;
      this.y = a.y;
      return this;
    };

    Vec2.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec2.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y;
    };

    Vec2.prototype.normalize = function() {
      var m;
      m = this.length();
      if (m > 0) {
        this.multScalar(1.0 / m);
      }
      return this;
    };

    Vec2.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    };

    Vec2.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    };

    Vec2.prototype.dv = function(v) {
      return new Vec2(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)));
    };

    Vec2.prototype.dist = function(v) {
      return Vec2.sub(this, v).length();
    };

    Vec2.prototype.distSquared = function(v) {
      return Vec2.sub(this, v).lengthSquared();
    };

    Vec2.prototype.div = function(n) {
      var _ref;
      _ref = [this.x / n.x, this.y / n.y], this.x = _ref[0], this.y = _ref[1];
      return this;
    };

    Vec2.prototype.mult = function(v) {
      var _ref;
      _ref = [this.x * v.x, this.y * v.y], this.x = _ref[0], this.y = _ref[1];
      return this;
    };

    Vec2.prototype.multScalar = function(n) {
      var _ref;
      _ref = [this.x * n, this.y * n], this.x = _ref[0], this.y = _ref[1];
      return this;
    };

    Vec2.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y;
    };

    Vec2.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Vec2.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
    };

    Vec2.prototype.flatten = function() {
      return [this.x, this.y];
    };

    return Vec2;

  })();

  /*Vec3
  */


  Vec3 = (function() {

    Vec3.prototype._DIM = 3;

    Vec3.sub = function(a, b) {
      return a.copy()["sub"](b);
    };

    Vec3.add = function(a, b) {
      return a.copy()["add"](b);
    };

    Vec3.cross = function(a, b) {
      return a.copy()["cross"](b);
    };

    Vec3.div = function(a, b) {
      return a.copy()["div"](b);
    };

    Vec3.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Vec3.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Vec3.normalize = function(a) {
      return a.copy()["normalize"]();
    };

    Vec3.dot = function(a, b) {
      return a.dot(b);
    };

    function Vec3(x, y, z) {
      var _ref;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      _ref = [x, y, z], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
    }

    Vec3.prototype.copy = function() {
      return new Vec3(this.x, this.y, this.z);
    };

    Vec3.prototype.copyFrom = function(a) {
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      return this;
    };

    Vec3.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec3.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Vec3.prototype.normalize = function() {
      var m;
      m = this.length();
      if (m > 0) {
        this.multScalar(1.0 / m);
      }
      return this;
    };

    Vec3.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    };

    Vec3.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    };

    Vec3.prototype.cross = function(v) {
      var x, y, z;
      x = this.y * v.z - this.z * v.y;
      y = this.z * v.x - this.x * v.z;
      z = this.x * v.y - this.y * v.x;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    };

    Vec3.prototype.dv = function(v) {
      return new Vec3(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z))));
    };

    Vec3.prototype.dist = function(v) {
      return Vec3.sub(this, v).length();
    };

    Vec3.prototype.distSquared = function(v) {
      return Vec3.sub(this, v).lengthSquared();
    };

    Vec3.prototype.div = function(n) {
      var _ref;
      _ref = [this.x / n.x, this.y / n.y, this.z / n.z], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      return this;
    };

    Vec3.prototype.mult = function(v) {
      var _ref;
      _ref = [this.x * v.x, this.y * v.y, this.z * v.z], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      return this;
    };

    Vec3.prototype.multScalar = function(n) {
      var _ref;
      _ref = [this.x * n, this.y * n, this.z * n], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      return this;
    };

    Vec3.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z;
    };

    Vec3.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    };

    Vec3.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z);
    };

    Vec3.prototype.flatten = function() {
      return [this.x, this.y, this.z];
    };

    return Vec3;

  })();

  /*Vec4
  */


  Vec4 = (function() {

    Vec4.prototype._DIM = 4;

    Vec4.sub = function(a, b) {
      return a.copy()["sub"](b);
    };

    Vec4.add = function(a, b) {
      return a.copy()["add"](b);
    };

    Vec4.cross = function(a, b) {
      return a.copy()["cross"](b);
    };

    Vec4.div = function(a, b) {
      return a.copy()["div"](b);
    };

    Vec4.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Vec4.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Vec4.normalize = function(a) {
      return a.copy()["normalize"]();
    };

    Vec4.dot = function(a, b) {
      return a.dot(b);
    };

    function Vec4(x, y, z, w) {
      var _ref;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      if (w == null) {
        w = 1;
      }
      _ref = [x, y, z, w], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
    }

    Vec4.prototype.copy = function() {
      return new Vec4(this.x, this.y, this.z, this.w);
    };

    Vec4.prototype.copyFrom = function(a) {
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      this.w = a.w;
      return this;
    };

    Vec4.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec4.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };

    Vec4.prototype.normalize = function() {
      var m;
      m = this.length();
      if (m > 0) {
        this.multScalar(1.0 / m);
      }
      return this;
    };

    Vec4.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    };

    Vec4.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
    };

    Vec4.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    };

    Vec4.prototype.cross = function(v) {
      var x, y, z;
      x = this.y * v.z - this.z * v.y;
      y = this.z * v.x - this.x * v.z;
      z = this.x * v.y - this.y * v.x;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    };

    Vec4.prototype.dv = function(v) {
      return new Vec4(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z)(Math.abs(this.w - v.w)))));
    };

    Vec4.prototype.dist = function(v) {
      return Vec4.sub(this, v).length();
    };

    Vec4.prototype.distSquared = function(v) {
      return Vec4.sub(this, v).lengthSquared();
    };

    Vec4.prototype.div = function(n) {
      var _ref;
      _ref = [this.x / n.x, this.y / n.y, this.z / n.z, this.w / n.w], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
      return this;
    };

    Vec4.prototype.mult = function(v) {
      var _ref;
      _ref = [this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
      return this;
    };

    Vec4.prototype.multScalar = function(n) {
      var _ref;
      _ref = [this.x * n, this.y * n, this.z * n, this.w * n], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
      return this;
    };

    Vec4.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };

    Vec4.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z) || this.w === Infinity || isNaN(this.w);
    };

    Vec4.prototype.flatten = function() {
      return [this.x, this.y, this.z, this.w];
    };

    return Vec4;

  })();

  /*Matrix2
  */


  Matrix2 = (function() {

    Matrix2.prototype._DIM = 2;

    Matrix2.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Matrix2.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Matrix2.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Matrix2.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Matrix2.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Matrix2.multVec = function(m, v) {
      var tv;
      tv = v.copy();
      m.multVec(tv);
      return tv;
    };

    Matrix2.transpose = function(a) {
      return a["_transpose"]();
    };

    function Matrix2(a) {
      if (a == null) {
        a = [1, 0, 0, 1];
      }
      if (a instanceof Matrix2) {
        this.a = a.a;
      } else {
        this.a = new glMatrixArrayType(a);
      }
    }

    Matrix2.prototype.copy = function() {
      return new Matrix2(this.a);
    };

    Matrix2.prototype.copyFrom = function(a) {
      var i, _i;
      for (i = _i = 0; _i <= 3; i = ++_i) {
        this.a[i] = a.a[i];
      }
      return this;
    };

    Matrix2.prototype.multScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num * n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix2.prototype.addScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num + n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix2.prototype.subScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num - n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix2.prototype.divScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num / n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix2.prototype.identity = function() {
      this.a.set([1, 0, 0, 1]);
      return this;
    };

    Matrix2.prototype.at = function(r, c) {
      return this.a[r * 2 + c];
    };

    Matrix2.prototype.mult = function(m) {
      var a;
      a = new Matrix2();
      a.a[0] = this.a[0] * m.a[0] + this.a[2] * m.a[1];
      a.a[1] = this.a[1] * m.a[0] + this.a[3] * m.a[1];
      a.a[2] = this.a[0] * m.a[2] + this.a[2] * m.a[3];
      a.a[3] = this.a[1] * m.a[2] + this.a[3] * m.a[3];
      this.copyFrom(a);
      return this;
    };

    Matrix2.prototype.multVec = function(v) {
      var x, y;
      if (v._DIM !== 2) {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
        return;
      }
      x = this.a[0] * v.x + this.a[2] * v.y;
      y = this.a[1] * v.x + this.a[3] * v.y;
      v.x = x;
      v.y = y;
      return this;
    };

    Matrix2.prototype.getCol = function(c) {
      c = c * Matrix2.DIM;
      return Vec2(this.a[c + 0](this.a[c + 1]));
    };

    Matrix2.prototype.getRow = function(r) {
      return Vec2(this.a[r + 0](this.a[r + 2]));
    };

    Matrix2.prototype._transpose = function() {
      return new Matrix2([this.a[0], a[2], this.a[1], this.a[3]]);
    };

    Matrix2.prototype.transpose = function() {
      this.copyFrom(this._transpose());
      return this;
    };

    Matrix2.prototype.print = function() {
      console.log(this.a[0] + "," + this.a[2]);
      return console.log(this.a[1] + "," + this.a[3]);
    };

    Matrix2.prototype.rotate = function(a) {
      var c, r, s;
      r = new Matrix2();
      s = Math.sin(a);
      c = Math.cos(a);
      r.a[0] = c;
      r.a[1] = s;
      r.a[2] = -s;
      r.a[3] = c;
      this.mult(r);
      return this;
    };

    Matrix2.prototype.scale = function(v) {
      var r;
      r = new Matrix3();
      r.a[0] = v.x;
      r.a[4] = v.y;
      r.a[8] = v.z;
      this.mult(r);
      return this;
    };

    return Matrix2;

  })();

  /*Matrix3
  */


  Matrix3 = (function() {

    Matrix3.prototype._DIM = 3;

    Matrix3.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Matrix3.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Matrix3.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Matrix3.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Matrix3.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Matrix3.invert = function(a) {
      return a["_invert"]();
    };

    Matrix3.multVec = function(m, v) {
      var tv;
      tv = v.copy();
      m.multVec(tv);
      return tv;
    };

    Matrix3.transpose = function(a) {
      return a["_transpose"]();
    };

    function Matrix3(a) {
      if (a == null) {
        a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      if (a instanceof Matrix3) {
        this.a = a.a;
      } else {
        this.a = new glMatrixArrayType(a);
      }
    }

    Matrix3.prototype.copy = function() {
      return new Matrix3(this.a);
    };

    Matrix3.prototype.copyFrom = function(a) {
      var i, _i;
      for (i = _i = 0; _i <= 8; i = ++_i) {
        this.a[i] = a.a[i];
      }
      return this;
    };

    Matrix3.prototype.multScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num * n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.addScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num + n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.subScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num - n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.divScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num / n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.identity = function() {
      this.a.set([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      return this;
    };

    Matrix3.prototype.at = function(r, c) {
      return this.a[r * 3 + c];
    };

    Matrix3.prototype.mult = function(m) {
      var a;
      a = new Matrix3();
      a.a[0] = this.a[0] * m.a[0] + this.a[3] * m.a[1] + this.a[6] * m.a[2];
      a.a[1] = this.a[1] * m.a[0] + this.a[4] * m.a[1] + this.a[7] * m.a[2];
      a.a[2] = this.a[2] * m.a[0] + this.a[5] * m.a[1] + this.a[8] * m.a[2];
      a.a[3] = this.a[0] * m.a[3] + this.a[3] * m.a[4] + this.a[6] * m.a[5];
      a.a[4] = this.a[1] * m.a[3] + this.a[4] * m.a[4] + this.a[7] * m.a[5];
      a.a[5] = this.a[2] * m.a[3] + this.a[5] * m.a[4] + this.a[8] * m.a[5];
      a.a[6] = this.a[0] * m.a[6] + this.a[3] * m.a[7] + this.a[6] * m.a[8];
      a.a[7] = this.a[1] * m.a[6] + this.a[4] * m.a[7] + this.a[7] * m.a[8];
      a.a[8] = this.a[2] * m.a[6] + this.a[5] * m.a[7] + this.a[8] * m.a[8];
      this.copyFrom(a);
      return this;
    };

    Matrix3.prototype.multVec = function(v) {
      var x, y, z;
      if (v._DIM !== 3) {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
        return;
      }
      x = this.a[0] * v.x + this.a[3] * v.y + this.a[6] * v.z;
      y = this.a[1] * v.x + this.a[4] * v.y + this.a[7] * v.z;
      z = this.a[2] * v.x + this.a[5] * v.y + this.a[8] * v.z;
      v.x = x;
      v.y = y;
      v.z = z;
      return this;
    };

    Matrix3.prototype.getCol = function(c) {
      c = c * Matrix3.DIM;
      return Vec3(this.a[c + 0](this.a[c + 1](this.a[c + 2])));
    };

    Matrix3.prototype.getRow = function(r) {
      return Vec3(this.a[r + 0](this.a[r + 3](this.a[r + 6])));
    };

    Matrix3.prototype._invert = function() {
      var det, epsilon, inv, invDet;
      inv = new Matrix3();
      epsilon = 4.37114e-05;
      inv.a[0] = this.a[4] * this.a[8] - this.a[5] * this.a[7];
      inv.a[1] = this.a[2] * this.a[7] - this.a[1] * this.a[8];
      inv.a[2] = this.a[1] * this.a[5] - this.a[2] * this.a[4];
      inv.a[3] = this.a[5] * this.a[6] - this.a[3] * this.a[8];
      inv.a[4] = this.a[0] * this.a[8] - this.a[2] * this.a[6];
      inv.a[5] = this.a[2] * this.a[3] - this.a[0] * this.a[5];
      inv.a[6] = this.a[3] * this.a[7] - this.a[4] * this.a[6];
      inv.a[7] = this.a[1] * this.a[6] - this.a[0] * this.a[7];
      inv.a[8] = this.a[0] * this.a[4] - this.a[1] * this.a[3];
      det = this.a[0] * inv.a[0] + this.a[1] * inv.a[3] + this.a[2] * inv.a[6];
      if (Math.abs(det) > epsilon) {
        invDet = 1.0 / det;
        inv.multScalar(invDet);
      }
      return inv;
    };

    Matrix3.prototype.invert = function() {
      this.copyFrom(this._invert());
      return this;
    };

    Matrix3.prototype._transpose = function() {
      return new Matrix3([this.a[0], this.a[3], this.a[6], this.a[1], this.a[4], this.a[7], this.a[2], this.a[5], this.a[8]]);
    };

    Matrix3.prototype.transpose = function() {
      this.copyFrom(this._transpose());
      return this;
    };

    Matrix3.prototype.print = function() {
      console.log(this.a[0] + "," + this.a[3] + "," + this.a[6]);
      console.log(this.a[1] + "," + this.a[4] + "," + this.a[7]);
      return console.log(this.a[2] + "," + this.a[5] + "," + this.a[8]);
    };

    Matrix3.prototype.rotate = function(v, a) {
      var c, r, s;
      r = new Matrix3();
      s = Math.sin(a);
      c = Math.cos(a);
      v.normalize();
      r.a[0] = v.x * v.x * (1 - c) + c;
      r.a[1] = v.x * v.y * (1 - c) + v.z * s;
      r.a[2] = v.x * v.z * (1 - c) - v.y * s;
      r.a[3] = v.x * v.y * (1 - c) - v.z * s;
      r.a[4] = v.y * v.y * (1 - c) + c;
      r.a[5] = v.y * v.z * (1 - c) + v.x * s;
      r.a[6] = v.x * v.z * (1 - c) + v.y * s;
      r.a[7] = v.y * v.z * (1 - c) - v.x * s;
      r.a[8] = v.z * v.z * (1 - c) + c;
      this.mult(r);
      return this;
    };

    Matrix3.prototype.scale = function(v) {
      var r;
      r = new Matrix3();
      r.a[0] = v.x;
      r.a[4] = v.y;
      r.a[8] = v.z;
      this.mult(r);
      return this;
    };

    return Matrix3;

  })();

  /*Matrix
  */


  Matrix4 = (function() {

    Matrix4.prototype._DIM = 4;

    Matrix4.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Matrix4.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Matrix4.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Matrix4.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Matrix4.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Matrix4.invert = function(a) {
      return a["_invert"]();
    };

    Matrix4.transpose = function(a) {
      return a["_transpose"]();
    };

    Matrix4.multVec = function(m, v) {
      var tv;
      tv = v.copy();
      m.multVec(tv);
      return tv;
    };

    function Matrix4(a) {
      if (a == null) {
        a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
      if (a instanceof Matrix4) {
        this.a = a.a;
      } else {
        this.a = new glMatrixArrayType(a);
      }
    }

    Matrix4.prototype.copy = function() {
      return new Matrix4(this.a);
    };

    Matrix4.prototype.copyFrom = function(a) {
      var i, _i;
      for (i = _i = 0; _i <= 15; i = ++_i) {
        this.a[i] = a.a[i];
      }
      return this;
    };

    Matrix4.prototype.multScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num * n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.addScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num + n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.subScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num - n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.divScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num / n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.identity = function() {
      this.a.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      return this;
    };

    Matrix4.prototype.at = function(r, c) {
      return this.a[r * 4 + c];
    };

    Matrix4.prototype.getMatrix3 = function() {
      return new Matrix3([this.a[0], this.a[1], this.a[2], this.a[4], this.a[5], this.a[6], this.a[8], this.a[9], this.a[10]]);
    };

    Matrix4.prototype.mult = function(m) {
      var a;
      a = new Matrix4();
      a.a[0] = this.a[0] * m.a[0] + this.a[4] * m.a[1] + this.a[8] * m.a[2] + this.a[12] * m.a[3];
      a.a[1] = this.a[1] * m.a[0] + this.a[5] * m.a[1] + this.a[9] * m.a[2] + this.a[13] * m.a[3];
      a.a[2] = this.a[2] * m.a[0] + this.a[6] * m.a[1] + this.a[10] * m.a[2] + this.a[14] * m.a[3];
      a.a[3] = this.a[3] * m.a[0] + this.a[7] * m.a[1] + this.a[11] * m.a[2] + this.a[15] * m.a[3];
      a.a[4] = this.a[0] * m.a[4] + this.a[4] * m.a[5] + this.a[8] * m.a[6] + this.a[12] * m.a[7];
      a.a[5] = this.a[1] * m.a[4] + this.a[5] * m.a[5] + this.a[9] * m.a[6] + this.a[13] * m.a[7];
      a.a[6] = this.a[2] * m.a[4] + this.a[6] * m.a[5] + this.a[10] * m.a[6] + this.a[14] * m.a[7];
      a.a[7] = this.a[3] * m.a[4] + this.a[7] * m.a[5] + this.a[11] * m.a[6] + this.a[15] * m.a[7];
      a.a[8] = this.a[0] * m.a[8] + this.a[4] * m.a[9] + this.a[8] * m.a[10] + this.a[12] * m.a[11];
      a.a[9] = this.a[1] * m.a[8] + this.a[5] * m.a[9] + this.a[9] * m.a[10] + this.a[13] * m.a[11];
      a.a[10] = this.a[2] * m.a[8] + this.a[6] * m.a[9] + this.a[10] * m.a[10] + this.a[14] * m.a[11];
      a.a[11] = this.a[3] * m.a[8] + this.a[7] * m.a[9] + this.a[11] * m.a[10] + this.a[15] * m.a[11];
      a.a[12] = this.a[0] * m.a[12] + this.a[4] * m.a[13] + this.a[8] * m.a[14] + this.a[12] * m.a[15];
      a.a[13] = this.a[1] * m.a[12] + this.a[5] * m.a[13] + this.a[9] * m.a[14] + this.a[13] * m.a[15];
      a.a[14] = this.a[2] * m.a[12] + this.a[6] * m.a[13] + this.a[10] * m.a[14] + this.a[14] * m.a[15];
      a.a[15] = this.a[3] * m.a[12] + this.a[7] * m.a[13] + this.a[11] * m.a[14] + this.a[15] * m.a[15];
      this.copyFrom(a);
      return this;
    };

    Matrix4.prototype.multVec = function(v) {
      var w, x, y, z;
      if (v._DIM !== 3 && v._DIM !== 4) {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
        return;
      }
      if (v._DIM === 3) {
        x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12];
        y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13];
        z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14];
        w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15];
        v.x = x / w;
        v.y = y / w;
        v.z = z / w;
      } else {
        x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12] * v.w;
        y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13] * v.w;
        z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14] * v.w;
        w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15] * v.w;
        v.x = x;
        v.y = y;
        v.z = z;
        v.w = w;
      }
      return this;
    };

    Matrix4.prototype.at = function(r, c) {
      return this.a[c * Matrix4.DIM + r];
    };

    Matrix4.prototype.getCol = function(c) {
      c = c * Matrix4.DIM;
      return Vec4(this.a[c + 0](this.a[c + 1](this.a[c + 2](this.a[c + 3]))));
    };

    Matrix4.prototype.getRow = function(r) {
      return Vec4(this.a[r + 0](this.a[r + 4](this.a[r + 8](this.a[r + 12]))));
    };

    Matrix4.prototype._invert = function() {
      var a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, det, epsilon, inv, invDet;
      inv = new Matrix4();
      epsilon = 4.37114e-05;
      a0 = this.a[0] * this.a[5] - this.a[1] * this.a[4];
      a1 = this.a[0] * this.a[6] - this.a[2] * this.a[4];
      a2 = this.a[0] * this.a[7] - this.a[3] * this.a[4];
      a3 = this.a[1] * this.a[6] - this.a[2] * this.a[5];
      a4 = this.a[1] * this.a[7] - this.a[3] * this.a[5];
      a5 = this.a[2] * this.a[7] - this.a[3] * this.a[6];
      b0 = this.a[8] * this.a[13] - this.a[9] * this.a[12];
      b1 = this.a[8] * this.a[14] - this.a[10] * this.a[12];
      b2 = this.a[8] * this.a[15] - this.a[11] * this.a[12];
      b3 = this.a[9] * this.a[14] - this.a[10] * this.a[13];
      b4 = this.a[9] * this.a[15] - this.a[11] * this.a[13];
      b5 = this.a[10] * this.a[15] - this.a[11] * this.a[14];
      det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
      if (Math.abs(det) > epsilon) {
        inv.a[0] = +this.a[5] * b5 - this.a[6] * b4 + this.a[7] * b3;
        inv.a[4] = -this.a[4] * b5 + this.a[6] * b2 - this.a[7] * b1;
        inv.a[8] = +this.a[4] * b4 - this.a[5] * b2 + this.a[7] * b0;
        inv.a[12] = -this.a[4] * b3 + this.a[5] * b1 - this.a[6] * b0;
        inv.a[1] = -this.a[1] * b5 + this.a[2] * b4 - this.a[3] * b3;
        inv.a[5] = +this.a[0] * b5 - this.a[2] * b2 + this.a[3] * b1;
        inv.a[9] = -this.a[0] * b4 + this.a[1] * b2 - this.a[3] * b0;
        inv.a[13] = +this.a[0] * b3 - this.a[1] * b1 + this.a[2] * b0;
        inv.a[2] = +this.a[13] * a5 - this.a[14] * a4 + this.a[15] * a3;
        inv.a[6] = -this.a[12] * a5 + this.a[14] * a2 - this.a[15] * a1;
        inv.a[10] = +this.a[12] * a4 - this.a[13] * a2 + this.a[15] * a0;
        inv.a[14] = -this.a[12] * a3 + this.a[13] * a1 - this.a[14] * a0;
        inv.a[3] = -this.a[9] * a5 + this.a[10] * a4 - this.a[11] * a3;
        inv.a[7] = +this.a[8] * a5 - this.a[10] * a2 + this.a[11] * a1;
        inv.a[11] = -this.a[8] * a4 + this.a[9] * a2 - this.a[11] * a0;
        inv.a[15] = +this.a[8] * a3 - this.a[9] * a1 + this.a[10] * a0;
      }
      invDet = 1.0 / det;
      inv.multScalar(invDet);
      return inv;
    };

    Matrix4.prototype.invert = function() {
      this.copyFrom(this._invert());
      return this;
    };

    Matrix4.prototype.transpose = function() {
      this.copyFrom(this._transpose());
      return this;
    };

    Matrix4.prototype._transpose = function() {
      return new Matrix4([this.a[0], this.a[4], this.a[8], this.a[12], this.a[1], this.a[5], this.a[9], this.a[13], this.a[2], this.a[6], this.a[10], this.a[14], this.a[3], this.a[7], this.a[11], this.a[15]]);
    };

    Matrix4.prototype.translate = function(v) {
      var r;
      if (v._DIM === 3 || v._DIM === _DIM) {
        r = new Matrix4();
        r.a[12] = v.x;
        r.a[13] = v.y;
        r.a[14] = v.z;
        this.mult(r);
      } else {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
      }
      return this;
    };

    Matrix4.prototype.setPos = function(v) {
      if (v.x != null) {
        this.a[12] = v.x;
      }
      if (v.y != null) {
        this.a[13] = v.y;
      }
      if (v.z != null) {
        this.a[14] = v.z;
      }
      return this;
    };

    Matrix4.prototype.getPos = function() {
      return new Vec3(this.a[12], this.a[13], this.a[14]);
    };

    Matrix4.prototype.print = function() {
      console.log(this.a[0] + "," + this.a[4] + "," + this.a[8] + "," + this.a[12]);
      console.log(this.a[1] + "," + this.a[5] + "," + this.a[9] + "," + this.a[13]);
      console.log(this.a[2] + "," + this.a[6] + "," + this.a[10] + "," + this.a[14]);
      return console.log(this.a[3] + "," + this.a[7] + "," + this.a[11] + "," + this.a[15]);
    };

    Matrix4.prototype.lookAt = function(eye, look, up) {
      var f, m, s, t, u, w;
      f = Vec3.sub(look, eye);
      f.normalize();
      u = up.copy();
      u.normalize();
      s = Vec3.cross(f, u);
      w = Vec3.cross(s, f);
      m = new Matrix4([s.x, u.x, -f.x, 0, s.y, u.y, -f.y, 0, s.z, u.z, -f.z, 0, 0, 0, 0, 1]);
      t = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -eye.x, -eye.y, -eye.z, 1]);
      m.mult(t);
      this.copyFrom(m);
      return this;
    };

    Matrix4.prototype.makePerspective = function(fovy, aspect, znear, zfar) {
      var xmax, xmin, ymax, ymin;
      ymax = znear * Math.tan(fovy * Math.PI / 360.0);
      ymin = -ymax;
      xmin = ymin * aspect;
      xmax = ymax * aspect;
      this.makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
      return this;
    };

    Matrix4.prototype.makeFrustum = function(left, right, bottom, top, znear, zfar) {
      var a, b, c, d, x, y;
      x = 2 * znear / (right - left);
      y = 2 * znear / (top - bottom);
      a = (right + left) / (right - left);
      b = (top + bottom) / (top - bottom);
      c = -(zfar + znear) / (zfar - znear);
      d = -2 * zfar * znear / (zfar - znear);
      this.a = new glMatrixArrayType([x, 0, 0, 0, 0, y, 0, 0, a, b, c, -1, 0, 0, d, 0]);
      return 0;
    };

    Matrix4.prototype.makeOrtho = function(left, right, bottom, top, znear, zfar) {
      var tx, ty, tz;
      tx = -(right + left) / (right - left);
      ty = -(top + bottom) / (top - bottom);
      tz = -(zfar + znear) / (zfar - znear);
      this.a = new glMatrixArrayType([2 / (right - left), 0, 0, tx, 0, 2 / (top - bottom), 0, ty, 0, 0, -2 / (zfar - znear), tz, 0, 0, 0, 1]);
      return this;
    };

    Matrix4.prototype.rotate = function(v, a) {
      var c, r, s;
      r = new Matrix4();
      s = Math.sin(a);
      c = Math.cos(a);
      v.normalize();
      r.a[0] = v.x * v.x * (1 - c) + c;
      r.a[1] = v.x * v.y * (1 - c) + v.z * s;
      r.a[2] = v.x * v.z * (1 - c) - v.y * s;
      r.a[4] = v.x * v.y * (1 - c) - v.z * s;
      r.a[5] = v.y * v.y * (1 - c) + c;
      r.a[6] = v.y * v.z * (1 - c) + v.x * s;
      r.a[8] = v.x * v.z * (1 - c) + v.y * s;
      r.a[9] = v.y * v.z * (1 - c) - v.x * s;
      r.a[10] = v.z * v.z * (1 - c) + c;
      this.mult(r);
      return this;
    };

    Matrix4.prototype.scale = function(v) {
      var r;
      r = new Matrix4();
      r.a[0] = v.x;
      r.a[5] = v.y;
      r.a[10] = v.z;
      this.mult(r);
      return this;
    };

    return Matrix4;

  })();

  /*Quaternion
  */


  Quaternion = (function() {

    Quaternion.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Quaternion.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Quaternion.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Quaternion.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Quaternion.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Quaternion.transVec3 = function(q, v) {
      var tv;
      tv = v.copy();
      q.transVec3(tv);
      return tv;
    };

    Quaternion.fromTo = function(f, t) {
      var tv;
      tv = new Quaternion();
      tv.fromTo(f, t);
      return tv;
    };

    function Quaternion(v, w) {
      if ((v == null) || (w == null)) {
        this.v = new Vec3(0, 0, 0);
        this.w = 1;
      } else {
        this.v = v.copy();
        this.w = w;
      }
    }

    Quaternion.prototype.copy = function() {
      return new Quaternion(this.v, this.w);
    };

    Quaternion.prototype.axis = function() {
      var ca, invlen;
      ca = w;
      invlen = 1.0 / Math.sqrt(1.0 - ca * ca);
      return Vec3.multScalar(v, invlen);
    };

    Quaternion.prototype.angle = function() {
      var ca;
      ca = w;
      return Math.acos(ca) * 2;
    };

    Quaternion.prototype.pitch = function() {
      return Math.atan2(2 * (this.v.y * this.v.z + this.w * this.v.x), this.w * this.w - this.v.x * this.v.x - this.v.y * this.v.y + this.v.z * this.v.z);
    };

    Quaternion.prototype.yaw = function() {
      return Math.sin(-2 * (this.v.x * this.v.z - this.w * this.v.y));
    };

    Quaternion.prototype.roll = function() {
      return Math.atan2(2 * (this.v.x * this.v.y + this.w * this.v.z), this.w * this.w + this.v.x * this.v.x - this.v.y * this.v.y - this.v.z * this.v.z);
    };

    Quaternion.prototype.dot = function(a) {
      return this.w * a.w + v.dot(a.v);
    };

    Quaternion.prototype.length = function() {
      return Math.sqrt(this.w * this.w + this.v.lengthSquared());
    };

    Quaternion.prototype.lengthSquared = function() {
      return w * w + this.v.lengthSquared();
    };

    Quaternion.prototype.invert = function() {
      var norm, normRecip;
      norm = this.w * this.w + this.v.x * this.v.x + this.v.y * this.v.y + this.v.z * this.v.z;
      if (Math.abs(norm) < EPSILON_VALUE) {
        return this.identity();
      }
      normRecip = 1.0 / norm;
      this.w = normRecip * w;
      this.v.multScalar(-normRecip);
      return this;
    };

    Quaternion.prototype.add = function(q) {
      this.w += q.w;
      this.v.x += q.v.x;
      this.v.y += q.v.y;
      this.v.z += q.v.z;
      return this;
    };

    Quaternion.prototype.sub = function(q) {
      this.w -= q.w;
      this.v.x -= q.v.x;
      this.v.y -= q.v.y;
      this.v.z -= q.v.z;
      return this;
    };

    Quaternion.prototype.multiply = function(q) {
      return this.mult(q);
    };

    Quaternion.prototype.mult = function(q) {
      this.w = this.w * q.w - this.v.x * q.v.x - this.v.y * q.v.y - this.v.z * q.v.z;
      this.v.x = q.w * this.v.x + q.v.x * this.w + q.v.y * this.v.z - q.v.z * this.v.y;
      this.v.y = q.w * this.v.y + q.v.y * this.w + q.v.z * this.v.x - q.v.x * this.v.z;
      this.v.z = q.w * this.v.z + q.v.z * this.w + q.v.x * this.v.y - q.v.y * this.v.x;
      return this;
    };

    Quaternion.prototype.multScalar = function(s) {
      this.w = this.w * s;
      this.v.multScalar(s);
      return this;
    };

    Quaternion.prototype.transVec3 = function(v) {
      var cm, pm, vm, x, y, z;
      vm = 2 * (this.v.x * v.x + this.v.y * v.y + this.v.z * v.z);
      cm = 2 * this.w;
      pm = cm * this.w - 1.0;
      x = pm * v.x + vm * this.v.x + cm * (this.v.y * v.z - this.v.z * v.y);
      y = pm * v.y + vm * this.v.y + cm * (this.v.z * v.x - this.v.x * v.z);
      z = pm * v.z + vm * this.v.z + cm * (this.v.x * v.y - this.v.y * v.x);
      v.x = x;
      v.y = y;
      v.z = z;
      return this;
    };

    Quaternion.prototype.normalize = function() {
      var len;
      len = this.length();
      if (len > 0) {
        this.w /= len;
        this.v.multScalar(1.0 / len);
      } else {
        this.w = 1.0;
        this.v.x = v.y = v.z = 0.0;
      }
      return this;
    };

    Quaternion.prototype.log = function() {
      var k, sintheta, t, theta;
      t = 1.0;
      if (this.w < t) {
        t = this.w;
      }
      theta = Math.acos(t);
      if (theta === 0) {
        return new Quaternion(this.v, 0);
      }
      sintheta = Math.sin(theta);
      k = theta / sintheta;
      if (Math.abs(sintheta) < 1 && Math.abs(theta) >= 3.402823466e+38 * Math.abs(sintheta)) {
        k = 1;
      }
      return new Quaternion(new Vec3(this.v.x * k, this.v.y * k, v.z * k), 0);
    };

    Quaternion.prototype.exp = function() {
      var costheta, k, sintheta, theta;
      theta = this.v.length();
      sintheta = sin(theta);
      k = sintheta / theta;
      if (Math.abs(theta) < 1 && Math.abs(sintheta) >= 3.402823466e+38 * Math.abs(theta)) {
        k = 1;
      }
      costheta = Math.cos(theta);
      return new Quaternion(new Vec3(this.v.x * k, this.v.y * k, v.z * k), costheta);
    };

    Quaternion.prototype.invert2 = function() {
      var qdot;
      qdot = this.dot();
      this.v = new Vec3(-this.v.x / qdot, -this.v.y / qdot, -this.v.z / qdot);
      this.w = this.w / qdot;
      return this;
    };

    Quaternion.prototype.fromTo = function(f, t) {
      var axis;
      axis = Vec3.cross(f, t);
      this.w = f.dot(t);
      this.v.x = axis.x;
      this.v.y = axis.y;
      this.v.z = axis.z;
      this.normalize();
      this.w += 1.0;
      if (this.w <= EPSILON_VALUE) {
        if (f.z * f.z > f.x * f.x) {
          this.w = 0.0;
          this.v.x = 0;
          this.v.y = f.z;
          this.v.z = -f.y;
        } else {
          this.w = 0.0;
          this.v.x = f.y;
          this.v.y = -f.x;
          this.v.z = 0.0;
        }
        this.normalize();
      }
      return this;
    };

    Quaternion.prototype.fromAxisAngle = function(a, r) {
      this.w = Math.cos(r / 2);
      this.v = Vec3.normalize(a).multScalar(Math.sin(r / 2));
      return this;
    };

    Quaternion.prototype.fromRotations = function(x, y, z) {
      var cx, cy, cz, sx, sy, sz;
      x *= 0.5;
      y *= 0.5;
      z *= 0.5;
      cx = Math.cos(x);
      sx = Math.sin(x);
      cy = Math.cos(y);
      sy = Math.sin(y);
      cz = Math.cos(z);
      sz = Math.sin(z);
      this.w = cx * cy * cz - sx * sy * sz;
      this.v.x = sx * cy * cx + cx * sy * sz;
      this.v.y = cx * sy * cz - sx * cy * sz;
      this.v.z = cx * cy * sz + sx * sy * cx;
      return this;
    };

    Quaternion.prototype.getAxisAngle = function() {
      var ca, invlen, r;
      ca = this.w;
      r = Math.acos(ca) * 2;
      invlen = 1.0 / Math.sqrt(1.0 - ca * ca);
      return [new Vec3(this.v.x * invlen, this.v.y * invlen, this.v.z * invlen), r];
    };

    Quaternion.prototype.getMatrix4 = function() {
      var wx, wy, wz, xs, xx, xy, xz, ys, yy, yz, zs, zz;
      xs = this.v.x + this.v.x;
      ys = this.v.y + this.v.y;
      zs = this.v.z + this.v.z;
      wx = this.w * xs;
      wy = this.w * ys;
      wz = this.w * zs;
      xx = this.v.x * xs;
      xy = this.v.x * ys;
      xz = this.v.x * zs;
      yy = this.v.y * ys;
      yz = this.v.y * zs;
      zz = this.v.z * zs;
      return new Matrix4([1.0 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1.0 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1.0 - (xx + yy), 0, 0, 0, 0, 1.0]);
    };

    Quaternion.prototype.lerp = function(t, end) {
      var costheta, result;
      costheta = end.dot();
      result = Quaternion.multScalar(end, t);
      if (costheta >= EPSILON_VALUE) {
        result.add(result.multScalar(1.0 - t));
      } else {
        result.add(result.multScalar(t - 1.0));
      }
      return result;
    };

    Quaternion.prototype.slerpShortestUnenforced = function(t, end) {
      var a, d, e, lengthD, lengthS, q, s, st;
      d = this.copy();
      d.sub(end);
      lengthD = Math.sqrt(this.dot(end));
      st = this.copy();
      st.add(end);
      lengthS = Math.sqrt(st.dot(st));
      a = 2 * Math.atan2(lengthD, lengthS);
      s = 1 - t;
      q = this.copy();
      q.multScalar(sinx_over_x(s * a) / sinx_over_x(a) * s);
      e = end.copy();
      e.multScalar(sinx_over_x(t * a) / sinx_over_x(a) * t);
      q.add(e);
      q.normalize();
      return q;
    };

    Quaternion.prototype.slerp = function(t, end) {
      var cosTheta, e, endInterp, q, recipSinTheta, startInterp, theta;
      cosTheta = this.dot(end);
      if (cosTheta >= EPSILON) {
        if (1.0 - cosTheta > EPSILON) {
          theta = Math.acos(cosTheta);
          recipSinTheta = 1.0 / Math.sin(theta);
          startInterp = Math.sin((1.0 - t) * theta) * recipSinTheta;
          endInterp = Math.sin(t * theta) * recipSinTheta;
        } else {
          startInterp = 1.0 - t;
          endInterp = t;
        }
      } else {
        if (1.0 + cosTheta > EPSILON) {
          theta = Math.acos(-cosTheta);
          recipSinTheta = 1.0 / Math.sin(theta);
          startInterp = Math.sin((t - 1.0) * theta) * recipSinTheta;
          endInterp = Math.sin(t * theta) * recipSinTheta;
        } else {
          startInterp = t(-1.0);
          endInterp = t;
        }
      }
      q = this.copy();
      q.mult(startInterp);
      e = end.copy();
      e.mult(endInterp);
      q.add(e);
      return q;
    };

    Quaternion.prototype.fromMatrix4 = function(m) {
      var a, b, i, j, k, recip, s, trace;
      trace = m.a[0] + m.a[5] + m.a[10];
      if (trace > 0.0) {
        s = Math.sqrt(trace + 1.0);
        this.w = s * 0.5;
        recip = 0.5 / s;
        this.v.x = (m.at(2, 1) - m.at(1, 2)) * recip;
        this.v.y = (m.at(0, 2) - m.at(2, 0)) * recip;
        this.v.z = (m.at(1, 0) - m.at(0, 1)) * recip;
      } else {
        i = 0;
        if (m.at(1, 1) > m.at(0, 0)) {
          i = 1;
        }
        if (m.at(2, 2) > m.at(i, i)) {
          i = 2;
        }
        j = (i + 1) % 3;
        k = (j + 1) % 3;
        s = Math.sqrt(m.at(i, i) - m.at(j, j) - m.at(k, k) + 1.0);
        if (i === 0) {
          this.v.x = 0.5 * s;
        } else if (i === 1) {
          this.v.y = 0.5 * s;
        } else {
          this.v.z = 0.5 * s;
        }
        recip = 0.5 / s;
        this.w = (m.at(k, j) - m.at(j, k)) * recip;
        a = (m.at(j, i) + m.at(i, j)) * recip;
        b = (m.at(k, i) + m.at(i, k)) * recip;
        if (j === 0) {
          this.v.x = a;
        } else if (j === 1) {
          this.v.y = a;
        } else {
          this.v.z = a;
        }
        if (k === 0) {
          this.v.x = b;
        } else if (k === 1) {
          this.v.y = b;
        } else {
          this.v.z = b;
        }
      }
      return this;
    };

    return Quaternion;

  })();

  module.exports = {
    Vec2: Vec2,
    Vec3: Vec3,
    Vec4: Vec4,
    Matrix2: Matrix2,
    Matrix3: Matrix3,
    Matrix4: Matrix4,
    radToDeg: radToDeg,
    degToRad: degToRad,
    Quaternion: Quaternion,
    PI: PI,
    rayPlaneIntersect: rayPlaneIntersect,
    precomputeTangent: precomputeTangent
  };

}).call(this);

},{"./error":19}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details

- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/
* https://github.com/field/FieldKit.js
*/


(function() {
  var App, CoffeeGLError, CoffeeGLLog, Colour, Matrix4, OrthoCamera, PerspCamera, Shader, Vec2, Vec3, Vec4, makeDebugContext, makeMouseEmitter, makeTouchEmitter, _ref, _ref1, _ref2, _ref3,
    _this = this;

  _ref = require("./math"), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4;

  Shader = require("./shader").Shader;

  _ref1 = require("./camera"), PerspCamera = _ref1.PerspCamera, OrthoCamera = _ref1.OrthoCamera;

  _ref2 = require("./signal"), makeMouseEmitter = _ref2.makeMouseEmitter, makeTouchEmitter = _ref2.makeTouchEmitter;

  Colour = require("./colour").Colour;

  _ref3 = require("./error"), CoffeeGLError = _ref3.CoffeeGLError, CoffeeGLLog = _ref3.CoffeeGLLog;

  makeDebugContext = require("./debug").makeDebugContext;

  /* App
  */


  App = (function() {

    function App(element, app_context, init, draw, update, onError, debug) {
      var _this = this;
      this.app_context = app_context;
      this.init = init;
      this.draw = draw;
      this.update = update;
      this.onError = onError;
      this.debug = debug != null ? debug : false;
      this.getDelta = function() {
        return App.prototype.getDelta.apply(_this, arguments);
      };
      this.run = function() {
        return App.prototype.run.apply(_this, arguments);
      };
      this.totalTime = 0.0;
      this.loops = 0;
      this.maxFrameSkip = 10;
      this.nextGameTick = (new Date).getTime();
      this.resources = 0;
      this.startTime = Date.now();
      this.oldTime = this.startTime;
      this.canvas = document.getElementById(element);
      this.height = this.canvas.height;
      this.width = this.canvas.width;
      this.gl = this.canvas.getContext('experimental-webgl');
      if (this.gl == null) {
        this.gl = canvas.getContext('webgl');
      }
      if (!this.gl) {
        if (this.onError != null) {
          this.onError();
        }
        CoffeeGLError("WebGL Not supported or context not found", "App");
        return;
      }
      this.profile();
      if (this.debug) {
        CoffeeGLLog("creating OpenGL debug context");
        makeDebugContext(this.gl);
      }
      this.resize(this.width, this.height);
      this._init();
    }

    App.prototype.profile = function() {
      var highp;
      this.profile = {};
      this.profile.antialias = this.gl.getContextAttributes().antialias;
      this.profile.aa_size = this.gl.getParameter(this.gl.SAMPLES);
      highp = this.gl.getShaderPrecisionFormat(this.gl.FRAGMENT_SHADER, this.gl.HIGH_FLOAT);
      this.profile.highpSupported = highp.precision !== 0;
      this.profile.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
      this.profile.maxCubeSize = this.gl.getParameter(this.gl.MAX_CUBE_MAP_TEXTURE_SIZE);
      this.profile.maxRenderbufferSize = this.gl.getParameter(this.gl.MAX_RENDERBUFFER_SIZE);
      this.profile.vertexTextureUnits = this.gl.getParameter(this.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this.profile.fragmentTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
      this.profile.combinedUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      this.profile.maxVSattribs = this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS);
      this.profile.maxVertexShaderUniforms = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);
      this.profile.maxFragmentShaderUniforms = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);
      this.profile.maxVaryings = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);
      return console.log(this.profile);
    };

    App.prototype.run = function() {
      this._draw();
      return this._update(this.getDelta());
    };

    App.prototype._init = function() {
      CoffeeGL.Context = this;
      if (typeof window !== "undefined" && window !== null) {
        window.GL = this.gl;
      }
      if (typeof window !== "undefined" && window !== null) {
        makeMouseEmitter(this);
      }
      if (typeof window !== "undefined" && window !== null) {
        makeTouchEmitter(this);
      }
      if (this.init != null) {
        this.init.call(this.app_context);
      }
      if (typeof window !== "undefined" && window !== null) {
        window.onEachFrame(this.run);
      }
      return this;
    };

    App.prototype.getDelta = function() {
      var deltaTime;
      deltaTime = Date.now() - this.oldTime;
      this.oldTime = Date.now();
      return deltaTime;
    };

    App.prototype.resize = function(w, h) {
      if (this.canvas) {
        if (this.gl) {
          this.width = w;
          this.height = h;
          this.gl.viewportWidth = this.width;
          this.gl.viewportHeight = this.height;
          return this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
        }
      }
    };

    App.prototype._draw = function() {
      CoffeeGL.Context = this;
      if (typeof window !== "undefined" && window !== null) {
        window.GL = this.gl;
      }
      if (this.draw != null) {
        return this.draw.call(this.app_context);
      }
    };

    App.prototype._update = function(dt) {
      if (this.update != null) {
        return this.update.call(this.app_context, dt);
      }
    };

    return App;

  })();

  module.exports = {
    App: App
  };

}).call(this);

},{"./math":3,"./shader":9,"./camera":13,"./signal":16,"./colour":5,"./error":19,"./debug":22}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


Primitive Objects - holds support for the various buffers we need


 - TODO
  * Should we use mixins or similar for adding texture co-ords and colours?
  * There is probably a much better methodology here I think
  * draw should be implicit when a primitive is created / added methinx - but what of order? Placement? Z Depth?

Three uses a dynamic flag. potential there.
Need to bind functions so that if vertices are updated, we change the buffers! Should be possible
Also, we are assuming floats here too! Normally thats the case but not always I suspect!
Also GL_TRIANGLES as well (but thats probably for the best)
Context is taken from the actual context set in the object but what if we wish to change context?
When applying materials, we may need to AUTOGEN stuff - thats not a bad idea actually
*/


(function() {
  var Geometry, Line, Matrix4, Quad, RGB, RGBA, TriStrip, Triangle, TriangleMesh, Vec2, Vec3, Vec4, Vertex, type, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./colour'), RGBA = _ref.RGBA, RGB = _ref.RGB;

  _ref1 = require('./math'), Matrix4 = _ref1.Matrix4, Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, Vec4 = _ref1.Vec4;

  /*Geometry
  */


  Geometry = (function() {

    function Geometry() {
      this.v = [];
      this.layout = "TRIANGLES";
      this.faces = [];
    }

    Geometry.prototype._addToNode = function(node) {
      node.geometry = this;
      return this;
    };

    return Geometry;

  })();

  /*Vertex
  */


  Vertex = (function() {

    function Vertex(p, c, n, t, tangent) {
      this.p = p;
      this.c = c;
      this.n = n;
      this.t = t;
      this.tangent = tangent;
      if (this.p == null) {
        this.p = new Vec3(0, 0, 0);
      }
    }

    Vertex.prototype.flatten = function() {
      var t;
      t = [];
      t.concat(this.p.flatten());
      if (this.c != null) {
        t.concat(this.c.flatten());
      }
      if (this.n != null) {
        t.concat(this.n.flatten());
      }
      if (this.t != null) {
        t.concat(this.t.flatten());
      }
      if (this.tangent != null) {
        t.concat(this.tangent.flatten());
      }
      return t;
    };

    return Vertex;

  })();

  type = function(obj) {
    var classToType, myClass, name, _i, _len, _ref2;
    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = new Object;
    _ref2 = "Boolean Number String Function Array Date";
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      name = _ref2[_i];
      RegExp.split(" ");
    }
    myClass = Object.prototype.toString.call(obj);
    if (myClass in classToType) {
      return classToType(myClass);
    }
    return 'object';
  };

  /*Triangle
  */


  Triangle = (function(_super) {

    __extends(Triangle, _super);

    function Triangle(p0, p1, p2, n) {
      this.n = n;
      Triangle.__super__.constructor.call(this);
      if ((p0 == null) || (p1 == null) || (p2 == null)) {
        this.v = [new Vertex(new Vec3(-1, -1, 0)), new Vertex(new Vec3(1, -1, 0)), new Vertex(new Vec3(0, 1, 0))];
      } else {
        this.v = [p0, p1, p2];
      }
      if (this.n == null) {
        this.computeFaceNormal();
      }
    }

    Triangle.prototype.flatten = function() {
      var t;
      t = [];
      t = t.concat(this.v[0].flatten());
      t = t.concat(this.v[1].flatten());
      t = t.concat(this.v[2].flatten());
      return t;
    };

    Triangle.prototype.computeFaceNormal = function() {
      var l0, l1;
      l0 = Vec3.sub(this.v[1].p, this.v[0].p);
      l1 = Vec3.sub(this.v[2].p, this.v[1].p);
      this.n = l0.cross(l1);
      this.n.normalize();
      return this;
    };

    return Triangle;

  })(Geometry);

  /*Quad
  */


  Quad = (function(_super) {

    __extends(Quad, _super);

    function Quad(p0, p1, p2, p3, n) {
      this.n = n;
      Quad.__super__.constructor.call(this);
      if ((p0 == null) || (p1 == null) || (p2 == null) || (p3 == null)) {
        p0 = new Vertex(new Vec3(-1, 1, 0), new RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(0, 1));
        p1 = new Vertex(new Vec3(-1, -1, 0), new RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(0, 0));
        p2 = new Vertex(new Vec3(1, 1, 0), new RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(1, 1));
        p3 = new Vertex(new Vec3(1, -1, 0), new RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(1, 0));
      }
      this.v = [p0, p1, p2, p3];
      this.layout = "TRIANGLE_STRIP";
      if (this.n == null) {
        this.computeFaceNormal();
      }
    }

    Quad.prototype.computeFaceNormal = function() {
      var l0, l1;
      l0 = Vec3.sub(this.v[1].p, this.v[0].p);
      l1 = Vec3.sub(this.v[2].p, this.v[1].p);
      this.n = l0.cross(l1);
      this.n.normalize();
      return this;
    };

    Quad.prototype.flatten = function() {
      var t;
      t = [];
      t = t.concat(this.v[0].flatten());
      t = t.concat(this.v[1].flatten());
      t = t.concat(this.v[2].flatten());
      t = t.concat(this.v[3].flatten());
      return t;
    };

    return Quad;

  })(Geometry);

  TriStrip = (function() {

    function TriStrip() {}

    return TriStrip;

  })();

  /*Line
  */


  Line = (function(_super) {

    __extends(Line, _super);

    function Line(s, e) {
      this.s = s;
      this.e = e;
      Line.__super__.constructor.call(this);
    }

    return Line;

  })(Geometry);

  /*TriangleMesh
  */


  TriangleMesh = (function(_super) {

    __extends(TriangleMesh, _super);

    function TriangleMesh(indexed) {
      this.indexed = indexed;
      TriangleMesh.__super__.constructor.call(this);
      this.v = [];
      this.faces = [];
      if ((this.indexed != null) === true) {
        this.indices = [];
      }
    }

    TriangleMesh.prototype.addTriangle = function(t) {
      var idx, p, ti, v, _i, _j, _len, _ref2;
      if (this.indices) {
        for (idx = _i = 0; _i <= 2; idx = ++_i) {
          p = this._findV(t.v[idx]);
          if (p === -1) {
            this.v.push(t.v[idx]);
            ti = this.v.length;
            ti -= 1;
            t.v[idx]._idx = ti;
            this.indices.push(ti);
          } else {
            this.indices.push(p);
          }
        }
      } else {
        _ref2 = t.v;
        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
          v = _ref2[_j];
          this.v.push(v);
        }
      }
      this.faces.push(t);
      return this;
    };

    TriangleMesh.prototype.addVertex = function(v) {
      this.v.push(v);
      return this;
    };

    TriangleMesh.prototype.addIndex = function(idx) {
      if (typeof indices !== "undefined" && indices !== null) {
        return indices.push(idx);
      }
    };

    /*
    addTriangleFromIndices : (indices) ->
      if @indices? 
        for v in indices
          if v >= @v.length
            console.log "CoffeeGL Warning - Adding indices past vertex range in TriangleMesh"
            return
          @indices.push v
      @
    
     addQuadFromIndices : (indices) ->
      if @indices? 
        for v in indices
          if v >= @v.length
            console.log "CoffeeGL Warning - Adding indices past vertex range in TriangleMesh"
            return
    
        @indices.push indices[0]
        @indices.push indices[1]
        @indices.push indices[2]
    
        @indices.push indices[0]
        @indices.push indices[2]
        @indices.push indices[3]
      @
    */


    TriangleMesh.prototype.addQuad = function(q) {
      var i, idx, p, ti, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
      if (this.indices) {
        _ref2 = [0, 1, 3];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          idx = _ref2[_i];
          p = this._findV(q.v[idx]);
          if (p === -1) {
            this.v.push(q.v[idx]);
            ti = this.v.length;
            ti -= 1;
            q.v[idx]._idx = ti;
            this.indices.push(ti);
          } else {
            this.indices.push(p);
          }
        }
        _ref3 = [2, 3, 1];
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          idx = _ref3[_j];
          p = this._findV(q.v[idx]);
          if (p === -1) {
            this.v.push(q.v[idx]);
            ti = this.v.length;
            ti -= 1;
            q.v[idx]._idx = ti;
            this.indices.push(ti);
          } else {
            this.indices.push(p);
          }
        }
      } else {
        _ref4 = [0, 1, 3];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          i = _ref4[_k];
          this.v.push(q.v[i]);
        }
        _ref5 = [2, 3, 1];
        for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
          i = _ref5[_l];
          this.v.push(q.v[i]);
        }
      }
      this.faces.push(new Triangle(q.v[0], q.v[1], q.v[3]));
      this.faces.push(new Triangle(q.v[2], q.v[3], q.v[1]));
      return this;
    };

    TriangleMesh.prototype._findV = function(vf) {
      var idx, _i, _ref2;
      if (vf._idx != null) {
        return vf._idx;
      }
      if (this.v.length > 0) {
        for (idx = _i = 0, _ref2 = this.v.length - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; idx = 0 <= _ref2 ? ++_i : --_i) {
          if (this.v[idx] === vf) {
            return idx;
          }
        }
      }
      return -1;
    };

    return TriangleMesh;

  })(Geometry);

  module.exports = {
    Geometry: Geometry,
    Vertex: Vertex,
    Triangle: Triangle,
    Quad: Quad,
    TriangleMesh: TriangleMesh
  };

}).call(this);

},{"./colour":5,"./math":3}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


Consists of a matrix, a material, parent and children for the scene graph computation
Doesnt have to be drawn per-se

If @geometry is attached, this node can be made drawable
If the node is made gldrawable, buffers will be attached to this node. The node then needs 
to be unbrewed.
*/


(function() {
  var Camera, Geometry, Material, Matrix3, Matrix4, Node, PointLight, Texture, Vec3, Vec4, makeNodeDrawableGL, util, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./math'), Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix3 = _ref.Matrix3, Matrix4 = _ref.Matrix4;

  makeNodeDrawableGL = require('./webgl').makeNodeDrawableGL;

  Camera = require('./camera').Camera;

  Material = require('./material').Material;

  Texture = require('./texture').Texture;

  PointLight = require('./Light').PointLight;

  Geometry = require('./primitives').Geometry;

  util = require('./util');

  /*Node
  */


  Node = (function() {

    function Node(geometry, material, textures, shader, pointLights) {
      this.geometry = geometry;
      this.material = material;
      this.textures = textures;
      this.shader = shader;
      this.pointLights = pointLights;
      this.matrix = new Matrix4();
      this._modelMatrix = new Matrix4();
      this._normalMatrix = new Matrix3();
      this.children = [];
      if (this.pointLights == null) {
        this.pointLights = [];
        this.pointLightsGlobal = [];
        this.numPointLights = 0;
      }
      if (this.textures == null) {
        this.textures = [];
      }
    }

    Node.prototype.add = function(p) {
      if (typeof p._addToNode === "function") {
        p._addToNode(this);
      }
      return this;
    };

    Node.prototype.remove = function(p) {
      if (typeof p._removeFromNode === "function") {
        p._removeFromNode(this);
      }
      return this;
    };

    Node.prototype._addToNode = function(node) {
      node.children.push(this);
      return this;
    };

    Node.prototype.copy = function() {
      return util.clone(this);
    };

    Node.prototype.del = function(p) {
      var i;
      if (__indexOf.call(this.children, p) >= 0) {
        i = this.children.indexOf(p);
        this.children.splice(i, 1);
      }
      return this;
    };

    Node.prototype._removeFromNode = function(node) {
      node.del(this);
      return this;
    };

    Node.prototype.draw = function() {
      var front;
      front = {
        _modelMatrix: new Matrix4(),
        _pointLightsGlobal: [],
        _normalMatrix: new Matrix4(),
        _camera: void 0,
        _shader: void 0
      };
      return this._draw(this, front);
    };

    Node.prototype._draw = function(node, front) {
      var child, cloned, light, newlight, nm, tex, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4;
      _ref1 = node.textures;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tex = _ref1[_i];
        tex.bind();
      }
      front._modelMatrix = Matrix4.mult(front._modelMatrix, node.matrix);
      nm = node._modelMatrix.copy();
      front._normalMatrix = nm.invert().transpose().getMatrix3();
      if (node.pointLights != null) {
        _ref2 = node.pointLights;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          light = _ref2[_j];
          newlight = util.clone(light);
          front._modelMatrix.multVec(newlight.pos);
          front._pointLightsGlobal.push(newlight);
        }
        front._numPointLightsGlobal = front._pointLightsGlobal.length;
      }
      if (node.camera != null) {
        front._camera = node.camera;
      }
      front._shader = node.shader;
      if (node.material != null) {
        front._material = node.material;
      }
      if (node.drawGL == null) {
        makeNodeDrawableGL(node);
        if (node.geometry != null) {
          if (!node.geometry.brewed) {
            node.brew();
          }
        }
      }
      node = util.extend(node, front);
      node.drawGL();
      _ref3 = node.children;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        child = _ref3[_k];
        cloned = {
          _modelMatrix: new Matrix4(front._modelMatrix),
          _pointLightsGlobal: [],
          _normalMatrix: new Matrix4(),
          _camera: front._camera,
          _material: front._material,
          _shader: front._shader
        };
        cloned._pointLightsGlobal = cloned._pointLightsGlobal.concat(front._pointLightsGlobal);
        this._draw(child, cloned);
      }
      _ref4 = node.textures;
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        tex = _ref4[_l];
        tex.unbind();
      }
      return node;
    };

    return Node;

  })();

  module.exports = {
    Node: Node
  };

}).call(this);

},{"./math":3,"./webgl":15,"./camera":13,"./material":18,"./texture":12,"./primitives":6,"./util":2,"./Light":23}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/

A mesh is a collection of triangles with or without indices.
All the triangles should have the same kinds of vertices 

- TODO
  * We split on materials at present. We should split on meshes if possible but
    not sure if the three.js supports that. For example, normal map and diffuse
    textures per mesh. Double check the three standard

  * There are texture loads in here. We need to set their callbacks and have a signal
    in here for when everything completes as 

JSONModel is a node that creates geometries below it which are also nodes
These geometries are drawn seperatly, each with their own material  
Accepts three.js style json model format
*/


(function() {
  var CoffeeGLWarning, JSONModel, LoadItem, LoadQueue, Material, Matrix4, Node, Quad, RGB, RGBA, Request, Signal, Texture, Triangle, TriangleMesh, Vec2, Vec3, Vec4, Vertex, _ref, _ref1, _ref2, _ref3,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./primitives'), Triangle = _ref.Triangle, Quad = _ref.Quad, Vertex = _ref.Vertex, TriangleMesh = _ref.TriangleMesh;

  Node = require('./node').Node;

  _ref1 = require('./math'), Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, Vec4 = _ref1.Vec4, Matrix4 = _ref1.Matrix4;

  Material = require('./material').Material;

  _ref2 = require('./colour'), RGB = _ref2.RGB, RGBA = _ref2.RGBA;

  Texture = require('./texture').Texture;

  Request = require('./request').Request;

  Signal = require('./signal').Signal;

  CoffeeGLWarning = require('./error').CoffeeGLWarning;

  _ref3 = require('./loader'), LoadItem = _ref3.LoadItem, LoadQueue = _ref3.LoadQueue;

  /*JSONModel
  */


  JSONModel = (function(_super) {

    __extends(JSONModel, _super);

    JSONModel.prototype._bitset = function(value, position) {
      return value & (1 << position);
    };

    function JSONModel(json_data, params) {
      var closure_parse, colourAmbient, colourDiffuse, colourSpecular, i, materials, model, n, path, specularCoef, tf, url, _i, _ref4,
        _this = this;
      this.params = params;
      this._parse = function(json_data) {
        return JSONModel.prototype._parse.apply(_this, arguments);
      };
      JSONModel.__super__.constructor.call(this);
      if (this.params == null) {
        this.params = {};
        this.params.texturing = true;
      } else {
        if (this.params.texturing == null) {
          this.params.texturing = true;
        }
      }
      this.queue = new LoadQueue(this, this.params.onItem, this.params.onLoad);
      materials = json_data["materials"];
      if (materials.length === 0) {
        this.add(new Node(new TriangleMesh(true)));
      } else {
        for (i = _i = 0, _ref4 = materials.length - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
          n = new Node();
          this.add(n);
          if (json_data["materials"][i]["DbgName"] != null) {
            n.dbgName = json_data["materials"][i]["DbgName"];
          }
          if (json_data["materials"][i]["DbgName"] === "default" || json_data["materials"][i]["DbgIndex"] === 1) {
            n.add(new Material());
          } else {
            colourAmbient = new RGB(json_data["materials"][i]["colorAmbient"][0], json_data["materials"][i]["colorAmbient"][1], json_data["materials"][i]["colorAmbient"][2]);
            if (colourAmbient == null) {
              colourAmbient = RGB.WHITE();
            }
            colourDiffuse = new RGB(json_data["materials"][i]["colorDiffuse"][0], json_data["materials"][i]["colorDiffuse"][1], json_data["materials"][i]["colorDiffuse"][2]);
            if (colourDiffuse == null) {
              colourDiffuse = RGB.WHITE();
            }
            colourSpecular = new RGB(json_data["materials"][i]["colorSpecular"][0], json_data["materials"][i]["colorSpecular"][1], json_data["materials"][i]["colorSpecular"][2]);
            if (colourSpecular == null) {
              colourSpecular = RGB.WHITE();
            }
            specularCoef = json_data["materials"][i]["specularCoef"];
            n.add(new Material(colourAmbient, colourDiffuse, colourSpecular, specularCoef));
          }
          n.geometry = new TriangleMesh(true);
          if (this.params.texturing) {
            if ((json_data["materials"][i]["mapDiffuse"] != null) && (json_data._coffeegl_request_url != null)) {
              url = json_data._coffeegl_request_url.substring(0, json_data._coffeegl_request_url.lastIndexOf("/"));
              path = url + "/" + json_data["materials"][i]["mapDiffuse"];
              tf = new LoadItem((function(n, path) {
                var _n, _path;
                _n = n;
                _path = path;
                return function() {
                  var t,
                    _this = this;
                  return t = new Texture(_path, {}, function() {
                    _n.add(t);
                    _this.loaded();
                    return _this;
                  });
                };
                return this;
              })(n, path));
              this.queue.add(tf);
            }
          }
        }
      }
      model = this;
      closure_parse = (function(n, model) {
        var data, _model,
          _this = this;
        data = json_data;
        _model = model;
        return function() {
          return _model._parse(data);
        };
      })(n, model);
      this.queue.add(new LoadItem(function() {
        closure_parse();
        return this.loaded();
      }));
      this.queue.start();
    }

    JSONModel.prototype._parse = function(json_data) {
      var child, cidx, i, i0, i1, i2, i3, midx, nidx, node_idx, prim, removals, type, type2, uvidx, vertices, vi0, vi1, vi2, vi3, vidx, _i, _j, _len, _len1, _ref4;
      node_idx = 0;
      vidx = 0;
      vertices = [];
      while (vidx < json_data["vertices"].length) {
        vertices.push(new Vertex(new Vec3(json_data["vertices"][vidx++], json_data["vertices"][vidx++], json_data["vertices"][vidx++])));
      }
      i = 0;
      while (i < json_data["faces"].length) {
        type = json_data["faces"][i++];
        prim;
        vi0;
        vi1;
        vi2;
        vi3;
        midx = {
          id: 0,
          type: -1
        };
        if (this._bitset(type, 0)) {
          vi0 = json_data["faces"][i++];
          vi1 = json_data["faces"][i++];
          vi2 = json_data["faces"][i++];
          vi3 = json_data["faces"][i++];
          prim = new Quad(vertices[vi0], vertices[vi1], vertices[vi2], vertices[vi3]);
        } else {
          vi0 = json_data["faces"][i++];
          vi1 = json_data["faces"][i++];
          vi2 = json_data["faces"][i++];
          prim = new Triangle(vertices[vi0], vertices[vi1], vertices[vi2]);
        }
        if (this._bitset(type, 1)) {
          midx.id = json_data["faces"][i++];
          type2 = type | 1;
          if (midx.type === -1) {
            midx.type = type2;
          } else {
            if (type2 !== midx.type) {
              CoffeeGLWarning("Different types within the same material");
            }
          }
        }
        if (this._bitset(type, 2)) {
          uvidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 3)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
            vertices[vi3].t = new Vec2(json_data["uvs"][0][i3 * 2], json_data["uvs"][0][i3 * 2 + 1]);
          }
          vertices[vi0].t = new Vec2(json_data["uvs"][0][i0 * 2], json_data["uvs"][0][i0 * 2 + 1]);
          vertices[vi1].t = new Vec2(json_data["uvs"][0][i1 * 2], json_data["uvs"][0][i1 * 2 + 1]);
          vertices[vi2].t = new Vec2(json_data["uvs"][0][i2 * 2], json_data["uvs"][0][i2 * 2 + 1]);
        }
        if (this._bitset(type, 4)) {
          nidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 5)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
            vertices[vi3].n = new Vec3(json_data["normals"][i3 * 3], json_data["normals"][i3 * 3 + 1], json_data["normals"][i3 * 3 + 2]);
          }
          vertices[vi0].n = new Vec3(json_data["normals"][i0 * 3], json_data["normals"][i0 * 3 + 1], json_data["normals"][i0 * 3 + 2]);
          vertices[vi1].n = new Vec3(json_data["normals"][i1 * 3], json_data["normals"][i1 * 3 + 1], json_data["normals"][i1 * 3 + 2]);
          vertices[vi2].n = new Vec3(json_data["normals"][i2 * 3], json_data["normals"][i2 * 3 + 1], json_data["normals"][i2 * 3 + 2]);
        }
        if (this._bitset(type, 6)) {
          cidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 7)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
          }
        }
        if (prim instanceof Triangle) {
          this.children[midx.id].geometry.addTriangle(prim);
        } else {
          this.children[midx.id].geometry.addQuad(prim);
        }
      }
      removals = [];
      _ref4 = this.children;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        child = _ref4[_i];
        if (child.geometry != null) {
          if (child.geometry.v.length === 0) {
            removals.push(child);
          }
        }
      }
      for (_j = 0, _len1 = removals.length; _j < _len1; _j++) {
        child = removals[_j];
        this.remove(child);
      }
      return this;
    };

    return JSONModel;

  })(Node);

  module.exports = {
    JSONModel: JSONModel
  };

}).call(this);

},{"./primitives":6,"./node":7,"./material":18,"./colour":5,"./math":3,"./texture":12,"./request":10,"./signal":16,"./error":19,"./loader":24}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


Framebuffer objects - reads the current active context from the exports and creates a FBO

Basic FBO with depth, linear filtering and RGBA with unsigned bytes

Remember, NPOT textures are support but not with repeats or mipmapping

- TODO
  * Depth options
*/


(function() {
  var CoffeeGLDebug, CoffeeGLError, Fbo, RGB, RGBA, TextureBase, Vec2, _ref, _ref1;

  _ref = require('./error'), CoffeeGLError = _ref.CoffeeGLError, CoffeeGLDebug = _ref.CoffeeGLDebug;

  _ref1 = require('./colour'), RGB = _ref1.RGB, RGBA = _ref1.RGBA;

  Vec2 = require('./math').Vec2;

  TextureBase = require('./texture').TextureBase;

  /*Fbo
  */


  Fbo = (function() {

    function Fbo(width, height, channels, datatype) {
      var gl;
      this.width = width;
      this.height = height;
      this.channels = channels;
      this.datatype = datatype;
      gl = CoffeeGL.Context.gl;
      if (!((this.width != null) && (this.height != null))) {
        this.width = CoffeeGL.Context.width;
        this.height = CoffeeGL.Context.height;
      }
      if (this.channels == null) {
        this.channels = gl.RGBA;
      }
      if (this.datatype == null) {
        this.datatype = gl.UNSIGNED_BYTE;
      }
      this.framebuffer = gl.createFramebuffer();
      CoffeeGLDebug("Created an FBO  with dimensions: " + this.width + "," + this.height);
      this._build();
    }

    Fbo.prototype.resize = function(w, h) {
      if (w instanceof Vec2) {
        this.width = w.x;
        this.height = w.y;
      } else if ((w != null) && (h != null)) {
        this.width = w;
        this.height = h;
      } else {
        return this;
      }
      this._build();
      return this;
    };

    Fbo.prototype._build = function() {
      var gl, params;
      gl = CoffeeGL.Context.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      if (this.texture == null) {
        params = {
          "min": gl.LINEAR,
          "max": gl.LINEAR,
          "wraps": gl.CLAMP_TO_EDGE,
          "wrapt": gl.CLAMP_TO_EDGE,
          "width": this.width,
          "height": this.height,
          "channels": this.channels,
          "datatype": this.datatype
        };
        this.texture = new TextureBase(params);
        this.texture.build();
      } else {
        this.texture.bind();
        gl.texImage2D(gl.TEXTURE_2D, 0, this.channels, this.width, this.height, 0, this.channels, this.datatype, null);
        this.texture.unbind();
      }
      this.renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
        return CoffeeGLError("Failed to Create Framebuffer!");
      }
    };

    Fbo.prototype.bind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
      return gl.viewport(0, 0, this.width, this.height);
    };

    Fbo.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };

    Fbo.prototype.clear = function(colour) {
      var gl;
      gl = CoffeeGL.Context.gl;
      if (colour == null) {
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
      } else {
        if (colour instanceof RGBA) {
          gl.clearColor(colour.r, colour.g, colour.b, colour.a);
        } else if (colour instanceof RGB) {
          gl.clearColor(colour.r, colour.g, colour.b, 0.0);
        }
      }
      return gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };

    Fbo.prototype.washUp = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.deleteFramebuffer(this.framebuffer);
      gl.deleteRenderbuffer(this.renderbuffer);
      gl.deleteTexture(this.texture.texture);
      return this;
    };

    return Fbo;

  })();

  module.exports = {
    Fbo: Fbo
  };

}).call(this);

},{"./error":19,"./colour":5,"./math":3,"./texture":12}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details



- TODO - Tighten up the contract
- TODO - Caching needs to go in here
*/


(function() {
  var CoffeeGLError, CoffeeGLLog, CoffeeGLWarning, Contract, Light, Matrix4, Shader, ShaderLibrary, Vec2, Vec3, Vec4, _ref, _ref1;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  Light = require('./light').Light;

  ShaderLibrary = require('./shader_library').ShaderLibrary;

  _ref1 = require('./error'), CoffeeGLError = _ref1.CoffeeGLError, CoffeeGLWarning = _ref1.CoffeeGLWarning, CoffeeGLLog = _ref1.CoffeeGLLog;

  /* Contract
  */


  Contract = (function() {

    function Contract(attributes, uniforms, textures) {
      this.attributes = attributes;
      this.uniforms = uniforms;
      this.textures = textures;
      if (this.attributes == null) {
        this.attributes = [];
      }
      if (this.uniforms == null) {
        this.uniforms = [];
      }
      if (this.textures == null) {
        this.textures = [];
      }
    }

    Contract.prototype.setUniformRole = function(uniform, role) {
      var u, _i, _len, _ref2;
      _ref2 = this.uniforms;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        u = _ref2[_i];
        if (u.name === uniform) {
          u.role = role;
        }
      }
      return this;
    };

    Contract.prototype.setAttributeRole = function(attribute, role) {
      var a, _i, _len, _ref2;
      _ref2 = this.attributes;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        a = _ref2[_i];
        if (a.name === attribute) {
          a.role = role;
        }
      }
      return this;
    };

    return Contract;

  })();

  /* Shader
  */


  Shader = (function() {

    function Shader(s, roles) {
      var gl, match, matches, type, _i, _j, _len, _len1;
      this._splitShader(s);
      if (this.sv == null) {
        CoffeeGLError("No Vertex Shader Provided");
        return;
      }
      if (this.sf == null) {
        CoffeeGLError("No Fragment Shader Provided");
        return;
      }
      if (CoffeeGL.Context == null) {
        CoffeeGLError("No Context for Shader Provided");
        return;
      }
      gl = CoffeeGL.Context.gl;
      matches = this.sv.match(/\{\{(ShaderLibrary\.[a-zA-Z]+)\}\}/g);
      if (matches != null) {
        for (_i = 0, _len = matches.length; _i < _len; _i++) {
          match = matches[_i];
          type = match.replace("}}", "").split(".")[1];
          if (ShaderLibrary[type] == null) {
            CoffeeGLError("Could not find " + type + "in Shader Library");
          } else {
            this.sv = this.sv.replace(match, ShaderLibrary[type].vertex);
          }
        }
      }
      matches = this.sf.match(/\{\{(ShaderLibrary\.[a-zA-Z]+)\}\}/g);
      if (matches != null) {
        for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
          match = matches[_j];
          type = match.replace("}}", "").split(".")[1];
          if (ShaderLibrary[type] == null) {
            CoffeeGLError("Could not find " + type + "in Shader Library");
          } else {
            this.sf = this.sf.replace(match, ShaderLibrary[type].fragment);
          }
        }
      }
      this.sv = this.sv.replace(/;(?! [a-zA-Z0-9])/g, ';\n');
      this.sv = this.sv.replace(/\{/g, '{\n');
      this.sv = this.sv.replace(/\}/g, '}\n');
      this.sf = this.sf.replace(/;(?! [a-zA-Z0-9])/g, ';\n');
      this.sf = this.sf.replace(/;(?! [a-zA-Z0-9])/g, ';\n');
      this.sf = this.sf.replace(/\{/g, '{\n');
      this.sf = this.sf.replace(/\}/g, '}\n');
      this.compile(roles);
    }

    Shader.prototype.compile = function(roles) {
      var attr, attrs, compilationLog, gl, idx, success, _i, _len;
      gl = CoffeeGL.Context.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      if (!this.vertexShader) {
        CoffeeGLError("No vertex shader object could be created");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      if (!this.fragmentShader) {
        CoffeeGLError("No Fragment shader object could be created");
      }
      gl.shaderSource(this.vertexShader, this.sv);
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        compilationLog = gl.getShaderInfoLog(this.vertexShader);
        CoffeeGLLog('Shader compiler log: ' + compilationLog);
        this._splitError(compilationLog, this.sv);
        CoffeeGLError("Could not compile vertex shader");
      }
      gl.shaderSource(this.fragmentShader, this.sf);
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        compilationLog = gl.getShaderInfoLog(this.fragmentShader);
        CoffeeGLLog("Shader compiler log: " + compilationLog);
        this._splitError(compilationLog, this.sf);
        CoffeeGLError("Could not compile fragment shader");
      }
      this.shaderProgram = gl.createProgram();
      attrs = this._parseShader("attribute");
      idx = 0;
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        attr = attrs[_i];
        gl.bindAttribLocation(this.shaderProgram, idx, attr.name);
        idx++;
      }
      gl.attachShader(this.shaderProgram, this.vertexShader);
      gl.attachShader(this.shaderProgram, this.fragmentShader);
      gl.linkProgram(this.shaderProgram);
      success = gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS);
      if (!success) {
        CoffeeGLWarning(gl.getProgramInfoLog(this.shaderProgram));
        CoffeeGLError("Failed to Link Shader");
      }
      this._makeContract(roles);
      return this;
    };

    Shader.prototype._addToNode = function(node) {
      node.shader = this;
      return this;
    };

    Shader.prototype._splitError = function(s, data) {
      var datalines, fileno, line, lineno, lines, match, message, _i, _len;
      lines = s.split('\n');
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        match = line.match(/ERROR: (\d+):(\d+): (.*)/);
        if (match) {
          fileno = parseInt(match[1], 10) - 1;
          lineno = parseInt(match[2], 10) - 1;
          message = match[3];
          datalines = data.split('\n');
          CoffeeGLLog("Shader Error Log: " + fileno + ", " + lineno + ", " + message + "," + datalines[lineno]);
        }
      }
      return this;
    };

    Shader.prototype._splitShader = function(s) {
      var pf, pv;
      pv = s.indexOf("##>VERTEX");
      pf = s.indexOf("##>FRAGMENT");
      if (pv < pf) {
        this.sv = s.slice(pv + 9, pf);
        this.sf = s.slice(pf + 11);
      } else {
        this.sf = s.slice(pf + 11, pv);
        this.sv = s.slice(pv + 9);
      }
      return this;
    };

    Shader.prototype._getLocation = function(name) {
      var gl;
      gl = CoffeeGL.Context.gl;
      return gl.getUniformLocation(this.shaderProgram, name);
    };

    Shader.prototype.bind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.useProgram(this.shaderProgram);
      CoffeeGL.Context.shader = this;
      return this;
    };

    Shader.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.useProgram(null);
      return this;
    };

    Shader.prototype.washUp = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.detachShader(this.shaderProgram, this.vertexShader);
      gl.detachShader(this.shaderProgram, this.fragmentShader);
      gl.deleteProgram(this.shaderProgram);
      gl.deleteShader(this.vertexShader);
      gl.deleteShader(this.fragmentShader);
      return this;
    };

    Shader.prototype._makeContract = function(user_roles) {
      var key, role, roles;
      this.contract = new Contract(this._getAttributes(), this._getUniforms(), this._getTextures());
      roles = {};
      roles.uModelMatrix = "_modelMatrix";
      roles.uProjectionMatrix = "_camera/p";
      roles.uCameraMatrix = "_camera/m";
      roles.uCameraInverseMatrix = "_camera/i";
      roles.uNormalMatrix = "_normalMatrix";
      roles.uMaterialAmbientColor = "_material/ambient";
      roles.uMaterialDiffuseColor = "_material/diffuse";
      roles.uMaterialSpecularColor = "_material/specular";
      roles.uMaterialShininess = "_material/shine";
      roles.uMaterialEmissiveColor = "_material/emissive";
      roles.uNumLights = "_numPointLightsGlobal";
      roles.uPointLightPos = "pointlight/pos";
      roles.uPointLightDiffuse = "pointlight/colour";
      roles.uPointLightSpecular = "pointlight/specular";
      roles.uPointLightAttenuation = "pointlight/attenuation";
      roles.aVertexPosition = "vertexPositionBuffer";
      roles.aVertexTexCoord = "vertexTextureBuffer";
      roles.aVertexNormal = "vertexNormalBuffer";
      roles.aVertexColour = "vertexColourBuffer";
      roles.aVertexTangent = "vertexTangentBuffer";
      if (user_roles != null) {
        for (key in user_roles) {
          roles[key] = user_roles[key];
        }
      }
      for (role in roles) {
        this.contract.setUniformRole(role, roles[role]);
        this.contract.setAttributeRole(role, roles[role]);
      }
      return this;
    };

    Shader.prototype._posForAttrRole = function(role) {
      var a, _i, _len, _ref2;
      _ref2 = this.contract.attributes;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        a = _ref2[_i];
        if (a.role === role) {
          return a.pos;
        }
      }
      return -1;
    };

    Shader.prototype._getAttributes = function() {
      var a, d, p, _i, _len;
      d = this._parseShader("attribute");
      for (_i = 0, _len = d.length; _i < _len; _i++) {
        a = d[_i];
        p = this.getAttribLocation(a.name);
        if ((p != null) && p !== -1) {
          a.pos = p;
        }
      }
      return d;
    };

    Shader.prototype._getUniforms = function() {
      var a, d, p, _i, _len;
      d = this._parseShader("uniform");
      for (_i = 0, _len = d.length; _i < _len; _i++) {
        a = d[_i];
        p = this._getLocation(a.name);
        if ((p != null) && p !== -1) {
          a.pos = p;
        }
      }
      return d;
    };

    Shader.prototype._getTextures = function() {
      var a, d, p, x, _i, _len;
      d = this._parseShader("uniform");
      x = [];
      for (_i = 0, _len = d.length; _i < _len; _i++) {
        a = d[_i];
        if (a.type === "sampler2D") {
          p = this._getLocation(a.name);
          if ((p != null) && p !== -1) {
            a.pos = p;
            x.push(a);
          }
        }
      }
      return x;
    };

    Shader.prototype._parseShader = function(token) {
      var attr, data, finals, l, lines, matches, re, t, tokens, _i, _j, _len, _len1;
      data = [];
      lines = this.sv.split(";").concat(this.sf.split(";"));
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        re = RegExp("\\b" + token + "\\b");
        if (l.match(re) != null) {
          tokens = l.split(" ");
          finals = [];
          for (_j = 0, _len1 = tokens.length; _j < _len1; _j++) {
            t = tokens[_j];
            t = t.replace(/\n/, "");
            t = t.replace(/\s/, "");
            if (t.length !== 0) {
              finals.push(t);
            }
          }
          finals.push(1);
          matches = finals[2].match(/\[([0-9]+)\]/);
          if (matches != null) {
            finals[3] = matches[1];
          }
          finals[2] = finals[2].match(/([a-zA-Z]+)/g)[0];
          if (finals.length === 4) {
            attr = {};
            attr.name = finals[2];
            attr.type = finals[1];
            attr.role = attr.name;
            attr.pos = -1;
            attr.size = finals[3];
            data.push(attr);
          }
        }
      }
      return data;
    };

    Shader.prototype.setUniform3f = function(name, a, b, c) {
      var gl;
      if ((a == null) || (b == null) || (c == null)) {
        CoffeeGLWarning("Not enough parameters to setUniform3f");
      }
      gl = CoffeeGL.Context.gl;
      gl.uniform3f(this._getLocation(name), a, b, c);
      return this;
    };

    Shader.prototype.setUniform3v = function(name, v) {
      var a, gl;
      gl = CoffeeGL.Context.gl;
      a = v.flatten();
      gl.uniform3f(this._getLocation(name), a[0], a[1], a[2]);
      return this;
    };

    Shader.prototype.setUniform4f = function(name, a, b, c, d) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform4f(this._getLocation(name), a, b, c, d);
      return this;
    };

    Shader.prototype.setUniform4v = function(name, v) {
      var a, gl;
      gl = CoffeeGL.Context.gl;
      a = v.flatten();
      gl.uniform4f(this._getLocation(name), a[0], a[1], a[2], a[3]);
      return this;
    };

    Shader.prototype.setUniform1f = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform1f(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform1i = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform1i(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform1fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform1fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform2fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform2fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform2v = function(name, v) {
      var a, gl;
      gl = CoffeeGL.Context.gl;
      a = v.flatten();
      gl.uniform3f(this._getLocation(name), a[0], a[1]);
      return this;
    };

    Shader.prototype.setUniform3fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform3fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform4fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform4fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setMatrix4f = function(name, m) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniformMatrix4fv(this._getLocation(name), false, m.a);
      return this;
    };

    Shader.prototype.enableAttribArray = function(name) {
      var gl, position;
      gl = CoffeeGL.Context.gl;
      position = gl.getAttribLocation(this.shaderProgram, name);
      gl.enableVertexAttribArray(position);
      return this;
    };

    Shader.prototype.getAttribLocation = function(name) {
      var gl;
      gl = CoffeeGL.Context.gl;
      return gl.getAttribLocation(this.shaderProgram, name);
    };

    return Shader;

  })();

  module.exports = {
    Shader: Shader
  };

}).call(this);

},{"./math":3,"./light":17,"./error":19,"./shader_library":25}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details



- TODO
  * TEST ORTHO CAMERA! I dont think it works! ><
  * update isnt really that great :S Keep it internal :)
  * functions to change the positions so we can change things like look pos and
    have the up vector change accordingly

https://gist.github.com/eligrey/384583 - useful for changes to pos,look etc?
*/


(function() {
  var Camera, Matrix4, MousePerspCamera, OrthoCamera, PerspCamera, Primitive, Quaternion, TouchPerspCamera, Vec3, Vec4, degToRad, makeMouseListener, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./math'), Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4, Quaternion = _ref.Quaternion, degToRad = _ref.degToRad;

  Primitive = require('./primitives').Primitive;

  makeMouseListener = require('./signal').makeMouseListener;

  /* Camera
  */


  Camera = (function() {

    function Camera(pos, look, up) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      if (this.pos == null) {
        this.pos = new Vec3(0, 0, 5);
      }
      if (this.look == null) {
        this.look = new Vec3(0, 0, 0);
      }
      if (this.up == null) {
        this.up = new Vec3(0, 1, 0);
      }
      this.m = new Matrix4();
      this.p = new Matrix4();
      this.i = new Matrix4();
    }

    Camera.prototype.update = function() {
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    Camera.prototype.rotateFocal = function(axis, angle) {
      var dir, q2;
      this.q.fromAxisAngle(axis, angle);
      dir = Vec3.sub(this.look, this.pos);
      dir.normalize();
      q2 = new Quaternion();
      q2.fromAxisAngle(Vec3.cross(dir, this.up), angle);
      q2.mult(this.q);
      q2.transVec3(this.pos);
      q2.transVec3(this.up);
      return this.update();
    };

    Camera.prototype._addToNode = function(node) {
      node.camera = this;
      return this;
    };

    return Camera;

  })();

  /* OrthoCamera
  */


  OrthoCamera = (function(_super) {

    __extends(OrthoCamera, _super);

    function OrthoCamera(pos, look, up, near, far) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.near = near;
      this.far = far;
      OrthoCamera.__super__.constructor.call(this, this.pos, this.look, this.up);
      if (this.near == null) {
        this.near = 0.1;
      }
      if (this.far == null) {
        this.far = 10.0;
      }
    }

    OrthoCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      OrthoCamera.__super__.update.call(this);
      this.p.makeOrtho(0, w, 0, h, this.near, this.far);
      return this;
    };

    return OrthoCamera;

  })(Camera);

  /* PerspCamera
  */


  PerspCamera = (function(_super) {

    __extends(PerspCamera, _super);

    function PerspCamera(pos, look, up, angle, near, far) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      PerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up);
      if (this.angle == null) {
        this.angle = 50.0;
      }
      if (this.near == null) {
        this.near = 0.1;
      }
      if (this.far == null) {
        this.far = 100.0;
      }
    }

    PerspCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      PerspCamera.__super__.update.call(this);
      this.p.makePerspective(this.angle, w / h, this.near, this.far);
      return this;
    };

    PerspCamera.prototype.castRay = function(sx, sy) {
      var g, gl, pp;
      if (CoffeeGL.Context != null) {
        gl = CoffeeGL.Context.gl;
        g = new Vec4((sx * 2) / CoffeeGL.Context.width - 1, 1 - (sy * 2) / CoffeeGL.Context.height, 1.0, 1.0);
        pp = Matrix4.mult(Matrix4.invert(this.m), Matrix4.invert(this.p));
        pp.multVec(g);
        g.normalize();
        return new Vec3(g.x, g.y, g.z);
      }
      return new Vec3(0, 0, 0);
    };

    return PerspCamera;

  })(Camera);

  /* MousePerspCamera
  */


  MousePerspCamera = (function(_super) {

    __extends(MousePerspCamera, _super);

    function MousePerspCamera(pos, look, up, angle, near, far, sense) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      this.sense = sense;
      MousePerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up, this.angle, this.near, this.far);
      CoffeeGL.Context.mouseMove.add(this.onMouseMove, this);
      CoffeeGL.Context.mouseDown.add(this.onMouseDown, this);
      CoffeeGL.Context.mouseUp.add(this.onMouseUp, this);
      CoffeeGL.Context.mouseWheel.add(this.onMouseWheel, this);
      if (this.sense == null) {
        this.sense = 0.3;
      }
      this._mouseDown = false;
      this.px = 0;
      this.py = 0;
      this.dx = 0;
      this.dy = 0;
      this.q = new Quaternion();
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      this;
    }

    MousePerspCamera.prototype.onMouseMove = function(event) {
      var dir, q2, x, y;
      if (this._mouseDown) {
        x = event.mouseX;
        y = event.mouseY;
        this.dx = x - this.px;
        this.px = x;
        this.dy = y - this.py;
        this.py = y;
        this.q.fromAxisAngle(new Vec3(0, 1, 0), degToRad(-this.dx * this.sense));
        dir = Vec3.sub(this.look, this.pos);
        dir.normalize();
        q2 = new Quaternion();
        q2.fromAxisAngle(Vec3.cross(dir, this.up), degToRad(this.dy * this.sense));
        q2.mult(this.q);
        q2.transVec3(this.pos);
        q2.transVec3(this.up);
      }
      return this;
    };

    MousePerspCamera.prototype.onMouseDown = function(event) {
      var x, y;
      this._mouseDown = true;
      x = event.mouseX;
      y = event.mouseY;
      this.px = x;
      this.py = y;
      this.dx = 0;
      this.dy = 0;
      return this;
    };

    MousePerspCamera.prototype.onMouseUp = function(event) {
      this._mouseDown = false;
      return this;
    };

    MousePerspCamera.prototype.onMouseWheel = function(event) {
      var dir;
      dir = Vec3.sub(this.look, this.pos);
      if (dir.length() > event.wheelDelta * 0.01 * this.sense * 2) {
        dir.normalize();
        dir.multScalar(event.wheelDelta * 0.01 * this.sense);
        this.pos.add(dir);
      }
      return this;
    };

    MousePerspCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      this.p.makePerspective(this.angle, w / h, this.near, this.far);
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    MousePerspCamera.prototype.onMouseOut = function(event) {
      this.px = 0;
      this.py = 0;
      this.dx = 0;
      return this.dy = 0;
    };

    MousePerspCamera.prototype.onMouseOver = function(event) {
      var _ref1;
      if (this.px === 0 && this.py === 0) {
        return _ref1 = [event.mouseX, event.mouseY], this.px = _ref1[0], this.py = _ref1[1], _ref1;
      }
    };

    return MousePerspCamera;

  })(PerspCamera);

  /* TouchPerspCamera
  */


  TouchPerspCamera = (function(_super) {

    __extends(TouchPerspCamera, _super);

    function TouchPerspCamera(pos, look, up, angle, near, far, sense) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      this.sense = sense;
      TouchPerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up, this.angle, this.near, this.far);
      CoffeeGL.Context.touchPinch.add(this.onPinch, this);
      CoffeeGL.Context.touchSpread.add(this.onSpread, this);
      CoffeeGL.Context.touchSwipe.add(this.onSwipe, this);
    }

    TouchPerspCamera.prototype.onPinch = function(event) {
      var dir;
      dir = Vec3.sub(this.look, this.pos);
      if (dir.length() > event.ddist * 0.1 * this.sense * 2) {
        dir.normalize();
        dir.multScalar(event.ddist * 0.1 * this.sense);
        this.pos.add(dir);
      }
      return this;
    };

    TouchPerspCamera.prototype.onSpread = function(event) {
      var dir;
      dir = Vec3.sub(this.look, this.pos);
      if (dir.length() > event.ddist * 0.1 * this.sense * 2) {
        dir.normalize();
        dir.multScalar(event.ddist * 0.1 * this.sense);
        this.pos.add(dir);
      }
      return this;
    };

    TouchPerspCamera.prototype.onSwipe = function(event) {
      var dir, q2, x, y;
      x = event.currentPos.x;
      y = event.currentPos.y;
      this.px = event.previousPos.x;
      this.py = event.previousPos.y;
      this.dx = x - this.px;
      this.px = x;
      this.dy = y - this.py;
      this.py = y;
      this.q.fromAxisAngle(new Vec3(0, 1, 0), degToRad(-this.dx * this.sense));
      dir = Vec3.sub(this.look, this.pos);
      dir.normalize();
      q2 = new Quaternion();
      q2.fromAxisAngle(Vec3.cross(dir, this.up), degToRad(-this.dy * this.sense));
      q2.mult(this.q);
      q2.transVec3(this.pos);
      q2.transVec3(this.up);
      return this;
    };

    return TouchPerspCamera;

  })(MousePerspCamera);

  module.exports = {
    Camera: Camera,
    OrthoCamera: OrthoCamera,
    PerspCamera: PerspCamera,
    MousePerspCamera: MousePerspCamera,
    TouchPerspCamera: TouchPerspCamera
  };

}).call(this);

},{"./math":3,"./signal":16,"./primitives":6}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


TODO - Probably pass in data and have a convinence method that calls a request?
  - handling no RGBA textures like JPGS?

https://developer.mozilla.org/en-US/docs/WebGL/Animating_textures_in_WebGL


Texture Objects - uses the request object and callbacks. Is bound to a context

- TODO 
  * How does this match with textures in the current shader context? Check that!
  * Video textures and compressed textures as per the spec for HTML5
*/


(function() {
  var Request, Texture, TextureBase, TextureCube,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Request = require('./request').Request;

  /*TextureBase
  */


  TextureBase = (function() {

    function TextureBase(params) {
      var gl;
      if (CoffeeGL.Context.gl == null) {
        console.log("Error - no context or url provided for texture");
      }
      gl = CoffeeGL.Context.gl;
      if (params == null) {
        params = {};
      }
      this.loaded = false;
      this.unit = params.unit == null ? 0 : params.unit;
      this.min = params.min == null ? gl.LINEAR : params.min;
      this.max = params.max == null ? gl.LINEAR : params.max;
      this.wraps = params.wraps == null ? gl.CLAMP_TO_EDGE : params.wraps;
      this.wrapt = params.wrapt == null ? gl.CLAMP_TO_EDGE : params.wrapt;
      this.width = params.width == null ? 512 : params.width;
      this.height = params.height == null ? 512 : params.height;
      this.channels = params.channels == null ? gl.RGBA : params.channels;
      this.datatype = params.datatype == null ? gl.UNSIGNED_BYTE : params.datatype;
      this.texture = gl.createTexture();
    }

    TextureBase.prototype.build = function() {
      var gl;
      if (CoffeeGL.Context.gl == null) {
        return;
      }
      gl = CoffeeGL.Context.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, this.channels, this.width, this.height, 0, this.channels, this.datatype, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.max);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.min);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wraps);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapt);
      gl.bindTexture(gl.TEXTURE_2D, null);
      this.loaded = true;
      return this;
    };

    TextureBase.prototype.bind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      if ((gl != null) && this.loaded) {
        gl.activeTexture(gl.TEXTURE0 + this.unit);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
      }
      return this;
    };

    TextureBase.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      if (this.loaded && (gl != null)) {
        gl.activeTexture(gl.TEXTURE0 + this.unit);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }
      return this;
    };

    TextureBase.prototype._addToNode = function(node) {
      node.textures.push(this);
      return this;
    };

    TextureBase.prototype._removeFromNode = function(node) {
      node.textures.splice(node.textures.indexOf(this));
      return this;
    };

    TextureBase.prototype.washUp = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.deleteTexture(this.texure);
      return this;
    };

    return TextureBase;

  })();

  /*Texture
  */


  Texture = (function(_super) {

    __extends(Texture, _super);

    function Texture(url, params, callback) {
      var gl, r,
        _this = this;
      this.url = url;
      this.callback = callback;
      Texture.__super__.constructor.call(this, params);
      if ((this.url == null) || (CoffeeGL.Context.gl == null)) {
        console.log("Error - no context or url provided for texture");
      }
      gl = CoffeeGL.Context.gl;
      r = new Request(this.url);
      r.get(function() {
        _this.texImage = new Image();
        _this.texImage.src = _this.url;
        return _this.texImage.onload = function() {
          _this.width = _this.texImage.width;
          _this.height = _this.texImage.height;
          _this.build(_this.texImage);
          _this.loaded = true;
          return typeof _this.callback === "function" ? _this.callback() : void 0;
        };
      });
    }

    Texture.prototype.build = function(texImage) {
      var gl;
      if (CoffeeGL.Context.gl == null) {
        return;
      }
      gl = CoffeeGL.Context.gl;
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, this.channels, this.channels, this.datatype, texImage);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.min);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.max);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wraps);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapt);
      return gl.bindTexture(gl.TEXTURE_2D, null);
    };

    Texture;

    return Texture;

  })(TextureBase);

  /*TextureCube
  */


  TextureCube = (function(_super) {

    __extends(TextureCube, _super);

    function TextureCube(paths, params) {
      var gl, i, loadedTextures, _i,
        _this = this;
      this.paths = paths;
      TextureCube.__super__.constructor.call(this, params);
      if ((this.paths == null) || (CoffeeGL.Context == null)) {
        console.log("Error - no context or urls provided for texture");
      }
      gl = CoffeeGL.Context.gl;
      this.texImages = [];
      loadedTextures = 0;
      for (i = _i = 0; _i <= 5; i = ++_i) {
        this.texImages[i] = new Image();
        this.texImages[i].cubeID = i;
        this.texImages[i].onload = function() {
          var j, _j;
          loadedTextures++;
          if (loadedTextures === 6) {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, _this.texture);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, _this.max);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, _this.min);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, _this.wraps);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, _this.wrapt);
            for (j = _j = 0; _j <= 5; j = ++_j) {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _this.texImages[j]);
            }
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return _this.loaded = true;
          }
        };
        this.texImages[i].src = this.paths[i];
      }
    }

    TextureCube.prototype.bind = function(unit) {
      var gl;
      gl = CoffeeGL.Context.gl;
      if ((gl != null) && this.loaded) {
        gl.activeTexture(gl.TEXTURE0 + this.unit);
        return gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
      }
    };

    TextureCube.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      if (this.loaded && (gl != null)) {
        gl.activeTexture(gl.TEXTURE0 + this.unit);
        return gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
      }
    };

    return TextureCube;

  })(TextureBase);

  module.exports = {
    Texture: Texture,
    TextureBase: TextureBase,
    TextureCube: TextureCube
  };

}).call(this);

},{"./request":10}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT   
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


- Resources

* http://coffeescriptcookbook.com/chapters/ajax/ajax_request_without_jquery

- TODO
  * Need to get some kind of percentage in here, along with a signal we can check!
  * Need to check if its binary, json or other here, properly!
*/


(function() {
  var CoffeeGL, Request, Signal;

  CoffeeGL = require('./coffeegl').CoffeeGL;

  Signal = require('./signal').Signal;

  /*Request
  */


  Request = (function() {

    function Request(url) {
      this.url = url;
    }

    Request.prototype.get = function(callback) {
      var _this = this;
      this.req = new XMLHttpRequest();
      this.req.onreadystatechange = function() {
        var data, l;
        if (_this.req.readyState === 4) {
          if (_this.req.status === 200 || _this.req.status === 304) {
            l = _this.url.length - 1;
            if (_this.url.indexOf("xml", l - 3) >= 0 || _this.url.indexOf("js", l - 2) >= 0 || _this.url.indexOf("json", l - 2) >= 0) {
              data = eval('(' + _this.req.responseText + ')');
              data._coffeegl_request_url = _this.url;
              callback(data);
            } else {
              callback(_this.req.responseText);
            }
          }
        }
        return _this;
      };
      this.req.open('GET', this.url);
      this.req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
      this.req.send(null);
      return this;
    };

    return Request;

  })();

  module.exports = {
    Request: Request
  };

}).call(this);

},{"./signal":16,"./coffeegl":1}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details
*/


(function() {
  var CoffeeGL, Cuboid, CurveCubic, Cylinder, Geometry, Node, PI, Quad, RGB, RGBA, Sphere, Triangle, Vec2, Vec3, Vertex, degToRad, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CoffeeGL = require('./coffeegl').CoffeeGL;

  Node = require('./node').Node;

  _ref = require('./colour'), RGB = _ref.RGB, RGBA = _ref.RGBA;

  _ref1 = require('./math'), Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, PI = _ref1.PI, degToRad = _ref1.degToRad;

  _ref2 = require('./primitives'), Vertex = _ref2.Vertex, Triangle = _ref2.Triangle, Quad = _ref2.Quad, Geometry = _ref2.Geometry;

  /*Cuboid
  */


  Cuboid = (function(_super) {

    __extends(Cuboid, _super);

    function Cuboid(dim, colour) {
      var d, h, i, w, _i, _ref3;
      Cuboid.__super__.constructor.call(this);
      if (dim == null) {
        dim = new Vec3(1.0, 1.0, 1.0);
      }
      w = dim.x / 2;
      h = dim.y / 2;
      d = dim.z / 2;
      this.v.push(new Vertex(new Vec3(-w, -h, d), colour, Vec3.normalize(new Vec3(-w, -h, d)), new Vec2(0, 0)));
      this.v.push(new Vertex(new Vec3(w, -h, d), colour, Vec3.normalize(new Vec3(w, -h, d)), new Vec2(1, 0)));
      this.v.push(new Vertex(new Vec3(w, h, d), colour, Vec3.normalize(new Vec3(w, h, d)), new Vec2(1, 1)));
      this.v.push(new Vertex(new Vec3(-w, h, d), colour, Vec3.normalize(new Vec3(-w, h, d)), new Vec2(0, 1)));
      this.v.push(new Vertex(new Vec3(-w, -h, -d), colour, Vec3.normalize(new Vec3(-w, -h, -d)), new Vec2(1, 1)));
      this.v.push(new Vertex(new Vec3(w, -h, -d), colour, Vec3.normalize(new Vec3(w, -h, -d)), new Vec2(1, 0)));
      this.v.push(new Vertex(new Vec3(w, h, -d), colour, Vec3.normalize(new Vec3(w, h, -d)), new Vec2(0, 0)));
      this.v.push(new Vertex(new Vec3(-w, h, -d), colour, Vec3.normalize(new Vec3(-w, h, -d)), new Vec2(0, 1)));
      this.indices = [0, 1, 2, 0, 2, 3, 6, 5, 4, 6, 4, 7, 4, 0, 3, 4, 3, 7, 1, 5, 2, 5, 6, 2, 3, 2, 6, 3, 6, 7, 4, 5, 1, 4, 1, 0];
      for (i = _i = 0, _ref3 = this.indices.length - 1; _i <= _ref3; i = _i += 3) {
        this.faces.push(new Triangle(this.v[this.indices[i]], this.v[this.indices[i + 1]], this.v[this.indices[i + 2]]));
      }
    }

    return Cuboid;

  })(Geometry);

  /*Sphere
  */


  Sphere = (function(_super) {

    __extends(Sphere, _super);

    function Sphere(radius, segments, center, colour) {
      var c, e, i, j, p, t, theta1, theta2, theta3, v, _i, _j, _k, _ref3, _ref4, _ref5;
      Sphere.__super__.constructor.call(this);
      this.layout = "TRIANGLE_STRIP";
      if (center == null) {
        center = new Vec3(0, 0, 0);
      }
      if (segments != null) {
        if (segments < 0) {
          segments = 10;
        }
      } else {
        segments = 10;
      }
      for (j = _i = 0, _ref3 = segments / 2; 0 <= _ref3 ? _i <= _ref3 : _i >= _ref3; j = 0 <= _ref3 ? ++_i : --_i) {
        theta1 = j * 2 * PI / segments - (PI / 2);
        theta2 = (j + 1) * 2 * PI / segments - (PI / 2);
        for (i = _j = 0, _ref4 = segments + 1; 0 <= _ref4 ? _j <= _ref4 : _j >= _ref4; i = 0 <= _ref4 ? ++_j : --_j) {
          e = new Vec3();
          theta3 = i * 2 * PI / segments;
          e.x = Math.cos(theta1) * Math.cos(theta3);
          e.y = Math.sin(theta1);
          e.z = Math.cos(theta1) * Math.sin(theta3);
          p = Vec3.multScalar(e, radius).add(center);
          c = new RGBA(1.0, 1.0, 1.0, 1.0);
          t = new Vec2(0.999 - i / segments, 0.999 - 2 * j / segments);
          v = new Vertex(p, c, e, t);
          this.v.push(v);
          e = new Vec3();
          e.x = Math.cos(theta2) * Math.cos(theta3);
          e.y = Math.sin(theta2);
          e.z = Math.cos(theta2) * Math.sin(theta3);
          p = Vec3.multScalar(e, radius).add(center);
          t = new Vec2(0.999 - i / segments, 0.999 - 2 * (j + 1) / segments);
          v = new Vertex(p, c, e, t);
          this.v.push(v);
        }
      }
      for (i = _k = 2, _ref5 = this.v.length - 1; _k <= _ref5; i = _k += 1) {
        if (i % 2 === 0) {
          this.faces.push(new Triangle(this.v[i], this.v[i - 1], this.v[i - 2]));
        } else {
          this.faces.push(new Triangle(this.v[i], this.v[i - 2], this.v[i - 1]));
        }
      }
    }

    return Sphere;

  })(Geometry);

  /*Cylinder
  */


  Cylinder = (function(_super) {

    __extends(Cylinder, _super);

    function Cylinder(radius, resolution, segments, height, colour) {
      var e, hstep, i, j, n, s, tangent, x, z, _i, _j, _k, _l, _m, _n, _o, _p, _ref3, _ref4, _ref5;
      Cylinder.__super__.constructor.call(this);
      this.indices = [];
      if (radius != null) {
        if (radius < 0) {
          radius = 0.5;
        }
      } else {
        radius = 0.5;
      }
      if (segments != null) {
        if (segments < 0) {
          segments = 10;
        }
      } else {
        segments = 10;
      }
      if (height != null) {
        if (height < 0) {
          height = 1.0;
        }
      } else {
        height = 1.0;
      }
      hstep = height / segments;
      height = height / 2.0;
      this.v.push(new Vertex(new Vec3(0, height, 0), colour, new Vec3(0, 1.0, 0.0), new Vec2(0.5, 0.0)));
      for (i = _i = 1; 1 <= resolution ? _i <= resolution : _i >= resolution; i = 1 <= resolution ? ++_i : --_i) {
        x = radius * Math.sin(degToRad(360.0 / resolution * i));
        z = radius * Math.cos(degToRad(360.0 / resolution * i));
        tangent = new Vec3(x, 0, z);
        tangent.normalize();
        tangent.cross(new Vec3(0, 1, 0));
        this.v.push(new Vertex(new Vec3(x, height, z), colour, Vec3.normalize(new Vec3(x, 1.0, z)), new Vec2(i / resolution, 0.0), tangent));
      }
      for (i = _j = 1; 1 <= resolution ? _j <= resolution : _j >= resolution; i = 1 <= resolution ? ++_j : --_j) {
        this.indices.push(0);
        this.indices.push(i);
        if (i === resolution) {
          this.indices.push(1);
        } else {
          this.indices.push(i + 1);
        }
      }
      for (i = _k = 1; 1 <= segments ? _k <= segments : _k >= segments; i = 1 <= segments ? ++_k : --_k) {
        for (j = _l = 1; 1 <= resolution ? _l <= resolution : _l >= resolution; j = 1 <= resolution ? ++_l : --_l) {
          x = radius * Math.sin(degToRad(360.0 / resolution * j));
          z = radius * Math.cos(degToRad(360.0 / resolution * j));
          tangent = new Vec3(x, 0, z);
          tangent.normalize();
          tangent.cross(new Vec3(0, -1, 0));
          n = Vec3.normalize(new Vec3(x, 0, z));
          if (i === segments) {
            n = Vec3.normalize(new Vec3(x, -1, z));
          }
          this.v.push(new Vertex(new Vec3(x, height - (hstep * i), z), colour, n, new Vec2(j / resolution, i / segments), tangent));
        }
        s = (i - 1) * resolution + 1;
        e = s + resolution;
        for (j = _m = 0, _ref3 = resolution - 1; 0 <= _ref3 ? _m <= _ref3 : _m >= _ref3; j = 0 <= _ref3 ? ++_m : --_m) {
          this.indices.push(s + j);
          this.indices.push(e + j);
          if (j === (resolution - 1)) {
            this.indices.push(e);
          } else {
            this.indices.push(e + j + 1);
          }
        }
        for (j = _n = 0, _ref4 = resolution - 1; 0 <= _ref4 ? _n <= _ref4 : _n >= _ref4; j = 0 <= _ref4 ? ++_n : --_n) {
          this.indices.push(s + j);
          if (j === (resolution - 1)) {
            this.indices.push(e);
            this.indices.push(s);
          } else {
            this.indices.push(e + j + 1);
            this.indices.push(s + j + 1);
          }
        }
      }
      this.v.push(new Vertex(new Vec3(0, -height, 0), colour, new Vec3(0, -1.0, 0.0), new Vec2(0.5, 1.0)));
      s = (segments * resolution) + 2;
      e = s + resolution - 1;
      for (i = _o = s; s <= e ? _o <= e : _o >= e; i = s <= e ? ++_o : --_o) {
        this.indices.push(s - 1);
        if (i === e) {
          this.indices.push(s);
        } else {
          this.indices.push(i + 1);
        }
        this.indices.push(i);
      }
      for (i = _p = 0, _ref5 = this.indices.length - 1; _p <= _ref5; i = _p += 3) {
        this.faces.push(new Triangle(this.v[this.indices[i]], this.v[this.indices[i + 1]], this.v[this.indices[i + 2]]));
      }
      this;
    }

    return Cylinder;

  })(Geometry);

  /*CurveCubic
  */


  CurveCubic = (function() {

    function CurveCubic(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }

    CurveCubic.prototype._B1 = function(t) {
      return t * t * t;
    };

    CurveCubic.prototype._B2 = function(t) {
      return 3 * t * t * (1 - t);
    };

    CurveCubic.prototype._B3 = function(t) {
      return 3 * t * (1 - t) * (1 - t);
    };

    CurveCubic.prototype._B4 = function(t) {
      return (1 - t) * (1 - t) * (1 - t);
    };

    CurveCubic.prototype.pointOnCurve = function(val) {
      return new Vector3(v0.x * this._B1(val) + v1.x * this._B2(val) + v2.x * this._B3(val) + v3.x * this._B4(val), v0.y * this._B1(val) + v1.y * this._B2(val) + v2.y * this._B3(val) + v3.y * this._B4(val), v0.z * this._B1(val) + v1.z * this._B2(val) + v2.z * this._B3(val) + v3.z * this._B4(val));
    };

    return CurveCubic;

  })();

  module.exports = {
    Cuboid: Cuboid,
    Sphere: Sphere,
    Cylinder: Cylinder,
    CurveCubic: CurveCubic
  };

}).call(this);

},{"./coffeegl":1,"./node":7,"./colour":5,"./math":3,"./primitives":6}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


The WebGL End of our basic primitives. Here we match our classes to the WebGL Shaders 
and buffers

 - TODO
  * Geometry may or may not have more buffers (should we wish to add them)
  * Do we put in face duplication here? I.e, if we want to pass in per face details
    we need to change the buffers
  * It appears that bufferSubData isnt the thing to use but is this true? (for updateing)
  * Geometry that has changed totally? Delete and redo buffers is needed
  * Per Face Brew method - I.e duplicate vertices if there is per-face data specified in
    the brew parameters
*/


(function() {
  var CoffeeGLWarning, CoffeeGLWarningOnce, Cuboid, Matrix4, Quad, RGB, RGBA, Sphere, Triangle, TriangleMesh, Vec2, Vec3, Vertex, WebGLNodeDrawable, brew, createArrayBuffer, createElementBuffer, deleteBuffer, drawGeometryGL, makeNodeDrawableGL, setDataBuffer, util, washup, _attribTypeCheckSet, _matchWithShader, _ref, _ref1, _ref2, _ref3, _ref4, _splitRole, _typeCheckSet;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec3 = _ref.Vec3, Vec2 = _ref.Vec2;

  _ref1 = require('./colour'), RGB = _ref1.RGB, RGBA = _ref1.RGBA;

  _ref2 = require('./primitives'), Vertex = _ref2.Vertex, Triangle = _ref2.Triangle, Quad = _ref2.Quad, TriangleMesh = _ref2.TriangleMesh;

  _ref3 = require('./shapes'), Cuboid = _ref3.Cuboid, Sphere = _ref3.Sphere;

  _ref4 = require('./error'), CoffeeGLWarning = _ref4.CoffeeGLWarning, CoffeeGLWarningOnce = _ref4.CoffeeGLWarningOnce;

  util = require("./util");

  setDataBuffer = function(buffer, data, type) {
    var gl;
    gl = CoffeeGL.Context.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, type);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
  };

  createArrayBuffer = function(data, type, size) {
    var buffer, gl;
    gl = CoffeeGL.Context.gl;
    buffer = gl.createBuffer();
    setDataBuffer(buffer, data, type);
    buffer.itemSize = size;
    buffer.numItems = data.length / size;
    return buffer;
  };

  createElementBuffer = function(data, type, size) {
    var buffer, gl;
    gl = CoffeeGL.Context.gl;
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, type);
    buffer.itemSize = size;
    buffer.numItems = data.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
  };

  deleteBuffer = function(buffer) {
    var gl;
    gl = CoffeeGL.Context.gl;
    gl.deleteBuffer(buffer);
    return this;
  };

  _attribTypeCheckSet = function(a, v) {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (a.pos === -1) {
      return;
    }
    gl.enableVertexAttribArray(a.pos);
    gl.bindBuffer(gl.ARRAY_BUFFER, v[a.role]);
    if (a.type === "int") {
      gl.vertexAttribPointer(a.pos, 1, gl.INT, false, 0, 0);
    } else if (a.type === "float") {
      gl.vertexAttribPointer(a.pos, 1, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec2") {
      gl.vertexAttribPointer(a.pos, 2, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec3") {
      gl.vertexAttribPointer(a.pos, 3, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec4") {
      gl.vertexAttribPointer(a.pos, 4, gl.FLOAT, false, 0, 0);
    }
    return this;
  };

  _typeCheckSet = function(u, v, tag) {
    var gl, idx, m, role, t, x, _i, _j, _k, _len, _len1, _len2, _ref5, _ref6, _ref7;
    if (u.pos === -1) {
      return;
    }
    role = u.role;
    if (tag != null) {
      role = _splitRole(tag, u.role);
    }
    gl = CoffeeGL.Context.gl;
    if (u.size === 1) {
      if (u.type === "float") {
        gl.uniform1f(u.pos, v[role]);
      } else if (u.type === "int") {
        gl.uniform1i(u.pos, v[role]);
      } else if (u.type === "vec2") {
        gl.uniform2f(u.pos, v[role].x, v[role].y);
      } else if (u.type === "vec3") {
        if (v[role].x != null) {
          gl.uniform3f(u.pos, v[role].x, v[role].y, v[role].z);
        } else {
          gl.uniform3f(u.pos, v[role].r, v[role].g, v[role].b);
        }
      } else if (u.type === "vec4") {
        if (v[role].x != null) {
          gl.uniform4f(u.pos, v[role].x, v[role].y, v[role].z, v[role].w);
        } else {
          gl.uniform4f(u.pos, v[role].r, v[role].g, v[role].b, v[role].a);
        }
      } else if (u.type === "mat4") {
        gl.uniformMatrix4fv(u.pos, false, v[role].a);
      } else if (u.type === "mat3") {
        gl.uniformMatrix3fv(u.pos, false, v[role].a);
      } else if (u.type === "sampler2D") {
        gl.uniform1i(u.pos, v[role]);
      }
    } else {
      if (v[role][0] instanceof Object) {
        t = [];
        if (v[role][0].flatten != null) {
          _ref5 = v[role];
          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
            x = _ref5[_i];
            t = t.concat(x.flatten());
          }
          if (u.type === "vec2") {
            gl.uniform2fv(u.pos, new Float32Array(t));
          } else if (u.type === "vec3") {
            gl.uniform3fv(u.pos, new Float32Array(t));
          } else if (u.type === "vec4") {
            gl.uniform4fv(u.pos, new Float32Array(t));
          }
        } else if (v[role][0].a) {
          if (u.type === "mat3") {
            t = new Float32Array(9 * v[role].length);
            idx = 0;
            _ref6 = v[role];
            for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
              m = _ref6[_j];
              t.set(m.a, idx * 9);
              idx++;
            }
            gl.uniformMatrix3fv(u.pos, false, new Float32Array(t));
          } else if (u.type === "mat4") {
            t = new Float32Array(16 * v[role].length);
            idx = 0;
            _ref7 = v[role];
            for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
              m = _ref7[_k];
              t.set(m.a, idx * 16);
              idx++;
            }
            gl.uniformMatrix4fv(u.pos, false, new Float32Array(t));
          }
        }
      } else {
        if (u.type === "float") {
          gl.uniform1fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "int") {
          gl.uniform1iv(u.pos, new Int32Array(v[role]));
        } else if (u.type === "vec2") {
          gl.uniform2fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "vec3") {
          gl.uniform3fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "vec4") {
          gl.uniform4fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "mat4") {
          gl.uniformMatrix4fv(u.pos, false, new Float32Array(v[role]));
        }
      }
    }
    return this;
  };

  _splitRole = function(tag, role) {
    if (role.indexOf(tag) !== -1) {
      return role.split("/")[1];
    }
    return role;
  };

  _matchWithShader = function(node) {
    var a, attenuations, colours, contract, light, pointlights, positions, shader, speculars, t, u, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref10, _ref11, _ref12, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (CoffeeGL.Context.shader == null) {
      console.log("CoffeeGL Error - Not Shader bound when calling _matchWithShader");
      return node;
    }
    if (CoffeeGL.Context.shader.contract == null) {
      console.log("CoffeeGL Error - Not Shader contract when calling _matchWithShader");
      return node;
    }
    contract = CoffeeGL.Context.shader.contract;
    shader = CoffeeGL.Context.shader;
    _ref5 = contract.uniforms;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      u = _ref5[_i];
      if (node[u.role] != null) {
        _typeCheckSet(u, node);
      }
    }
    if (node._camera != null) {
      _ref6 = contract.uniforms;
      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
        u = _ref6[_j];
        if (node._camera[_splitRole("camera", u.role)] != null) {
          _typeCheckSet(u, node._camera, "camera");
        }
      }
    }
    if (node._material != null) {
      _ref7 = contract.uniforms;
      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
        u = _ref7[_k];
        if (node._material[_splitRole("material", u.role)] != null) {
          _typeCheckSet(u, node._material, "material");
        }
      }
    }
    if (node._pointLightsGlobal.length > 0) {
      positions = [];
      colours = [];
      speculars = [];
      attenuations = [];
      _ref8 = node._pointLightsGlobal;
      for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
        light = _ref8[_l];
        positions = positions.concat(light.pos.flatten());
        colours = colours.concat(light.colour.flatten());
        speculars = speculars.concat(light.specular.flatten());
        attenuations.push(light.attenuation);
      }
      positions = new Float32Array(positions);
      colours = new Float32Array(colours);
      speculars = new Float32Array(speculars);
      attenuations = new Float32Array(attenuations);
      pointlights = {
        pos: positions,
        colour: colours,
        specular: speculars,
        attenuations: attenuations
      };
      _ref9 = contract.uniforms;
      for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
        u = _ref9[_m];
        if (pointlights[_splitRole("pointlight", u.role)] != null) {
          _typeCheckSet(u, pointlights, "pointlight");
        }
      }
    }
    if (node.textures != null) {
      _ref10 = contract.textures;
      for (_n = 0, _len5 = _ref10.length; _n < _len5; _n++) {
        u = _ref10[_n];
        _ref11 = node.textures;
        for (_o = 0, _len6 = _ref11.length; _o < _len6; _o++) {
          t = _ref11[_o];
          if (t[_splitRole("texture", u.role)] != null) {
            _typeCheckSet(u, t, "texture");
          }
        }
      }
    }
    if (node.geometry != null) {
      _ref12 = contract.attributes;
      for (_p = 0, _len7 = _ref12.length; _p < _len7; _p++) {
        a = _ref12[_p];
        if (node.geometry[a.role] != null) {
          _attribTypeCheckSet(a, node.geometry);
        }
      }
    }
    return node;
  };

  drawGeometryGL = function(geometry, drawPrimitive) {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (drawPrimitive == null) {
      if (geometry.layout == null) {
        drawPrimitive = gl.TRIANGLES;
      } else {
        if (geometry.layout === "TRIANGLE_STRIP") {
          drawPrimitive = gl.TRIANGLE_STRIP;
        } else if (geometry.layout === "POINTS") {
          drawPrimitive = gl.POINTS;
        } else {
          drawPrimitive = gl.TRIANGLES;
        }
      }
    }
    if (geometry.vertexIndexBuffer != null) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.vertexIndexBuffer);
      return gl.drawElements(drawPrimitive, geometry.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    } else {
      return gl.drawArrays(drawPrimitive, 0, geometry.vertexPositionBuffer.numItems);
    }
  };

  brew = function(geometry, params) {
    var access, colours, gl, normals, size, tangents, uvs, v, vertices, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref5, _ref6, _ref7, _ref8, _ref9;
    if ((geometry.v == null) || geometry.v.length <= 0) {
      geometry.brewed = false;
      return this;
    }
    gl = CoffeeGL.Context.gl;
    if (params == null) {
      params = {};
    }
    vertices = [];
    _ref5 = geometry.v;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      v = _ref5[_i];
      vertices = vertices.concat(v.p.flatten());
    }
    access = params.position_buffer_access != null ? params.position_buffer_access : gl.STATIC_DRAW;
    if (geometry.vertexPositionBuffer == null) {
      geometry.vertexPositionBuffer = createArrayBuffer(new Float32Array(vertices), access, 3);
    } else {
      if (v.length === geometry.vertexPositionBuffer.numItems) {
        setDataBuffer(geometry.vertexPositionBuffer, new Float32Array(vertices), access);
      } else {
        CoffeeGLWarningOnce("Attemping to update position buffer of different length");
      }
    }
    if (geometry.v[0].c != null) {
      access = params.colour_buffer_access != null ? params.colour_buffer_access : gl.STATIC_DRAW;
      colours = [];
      _ref6 = geometry.v;
      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
        v = _ref6[_j];
        colours = colours.concat(v.c.flatten());
      }
      if (!geometry.vertexColourBuffer) {
        size = 4;
        if (geometry.v[0].c instanceof RGB) {
          size = 3;
        }
        geometry.vertexColourBuffer = createArrayBuffer(new Float32Array(colours), access, size);
      } else {
        if (v.length === geometry.vertexColourBuffer.numItems) {
          setDataBuffer(geometry.vertexColourBuffer, new Float32Array(colours), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update colour buffer of different length");
        }
      }
    }
    if (geometry.indices != null) {
      access = params.indices_buffer_access != null ? params.indices_buffer_access : gl.STATIC_DRAW;
      if (geometry.vertexIndexBuffer == null) {
        geometry.vertexIndexBuffer = createElementBuffer(new Uint16Array(geometry.indices), access, 1);
      } else {
        if (v.length === geometry.vertexIndexBuffer.numItems) {
          setDataBuffer(geometry.vertexIndexBuffer, new Float32Array(geometry.indices), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update indices buffer of different length");
        }
      }
    }
    if (geometry.v[0].n != null) {
      normals = [];
      access = params.normal_buffer_access != null ? params.normal_buffer_access : gl.STATIC_DRAW;
      _ref7 = geometry.v;
      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
        v = _ref7[_k];
        normals = normals.concat(v.n.flatten());
      }
      if (geometry.vertexNormalBuffer == null) {
        geometry.vertexNormalBuffer = createArrayBuffer(new Float32Array(normals), access, 3);
      } else {
        if (v.length === geometry.vertexNormalBuffer.numItems) {
          setDataBuffer(geometry.vertexNormalBuffer, new Float32Array(normals), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update normals buffer of different length");
        }
      }
    }
    if (geometry.v[0].t != null) {
      uvs = [];
      access = params.texcoord_buffer_access != null ? params.texcoord_buffer_access : gl.STATIC_DRAW;
      _ref8 = geometry.v;
      for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
        v = _ref8[_l];
        uvs = uvs.concat(v.t.flatten());
      }
      if (geometry.vertexTextureBuffer == null) {
        geometry.vertexTextureBuffer = createArrayBuffer(new Float32Array(uvs), access, 2);
      } else {
        if (v.length === geometry.vertexTextureBuffer.numItems) {
          setDataBuffer(geometry.vertexIndexBuffer, new Float32Array(uvs), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update texture co-ord buffer of different length");
        }
      }
    }
    if (geometry.v[0].tangent != null) {
      tangents = [];
      access = params.tangent_buffer_access != null ? params.tangent_buffer_access : gl.STATIC_DRAW;
      _ref9 = geometry.v;
      for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
        v = _ref9[_m];
        tangents = tangents.concat(v.tangent.flatten());
      }
      if (geometry.vertexTangentBuffer == null) {
        geometry.vertexTangentBuffer = createArrayBuffer(new Float32Array(tangents), access, 3);
      } else {
        if (v.length === geometry.vertexTangentBuffer.numItems) {
          setDataBuffer(geometry.vertexTangentBuffer, new Float32Array(tangents), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update tangent buffer of different length");
        }
      }
    }
    geometry.brewed = true;
    return this;
  };

  washup = function(geometry) {
    return this;
  };

  WebGLNodeDrawable = {};

  WebGLNodeDrawable.drawGL = function() {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (this._shader != null) {
      CoffeeGL.Context.shader = this._shader;
    }
    if (CoffeeGL.Context.shader == null) {
      return this;
    }
    CoffeeGL.Context.shader.bind();
    _matchWithShader(this);
    if (this.geometry) {
      drawGeometryGL(this.geometry);
    }
    return this;
  };

  WebGLNodeDrawable.brew = function() {
    return brew(this.geometry);
  };

  makeNodeDrawableGL = function(node) {
    util.extend(node, WebGLNodeDrawable);
    if (node.geometry != null) {
      if (node.geometry.brewed == null) {
        node.geometry.brewed = false;
      }
    }
    return this;
  };

  module.exports = {
    makeNodeDrawableGL: makeNodeDrawableGL
  };

}).call(this);

},{"./math":3,"./colour":5,"./primitives":6,"./shapes":14,"./error":19,"./util":2}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details



# There is no hierarchy or bubbling really. Anyone can listen

- TODO
  * Drag, double click etc
  * inbuilt dx,dy
  * Is there some kind of signals lib for Coffeescript? Like the signals in JS?

Influenced by signals.js - an object where listeners and events may be added
*/


(function() {
  var Signal, Vec2, makeMouseEmitter, makeTouchEmitter, mouseEmitter, touchEmitter, util;

  util = require("./util");

  Vec2 = require("./math").Vec2;

  /*Signal
  */


  Signal = (function() {

    function Signal() {
      this.listeners = [];
    }

    Signal.prototype.add = function(func, context) {
      this.listeners.push({
        f: func,
        c: context,
        o: false
      });
      return this;
    };

    Signal.prototype.addOnce = function(func, context) {
      this.listeners.push({
        f: func,
        c: context,
        o: true
      });
      return this;
    };

    Signal.prototype.remove = function(func, context) {
      this.del(func);
      return this;
    };

    Signal.prototype.del = function(func, context) {
      var i, obj, _i, _len, _ref;
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj.c === context) {
          if (obj.f === func) {
            i = this.listeners.indexOf(obj);
            this.listeners.splice(i, 1);
            break;
          }
        }
      }
      return this;
    };

    Signal.prototype.dispatch = function() {
      var l, removals, _i, _j, _len, _len1, _ref;
      removals = [];
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        l.f.apply(l.c, arguments);
        if (l.o) {
          removals.push(l);
        }
      }
      for (_j = 0, _len1 = removals.length; _j < _len1; _j++) {
        l = removals[_j];
        this.del(l);
      }
      return this;
    };

    return Signal;

  })();

  /*MouseEmitter
  */


  mouseEmitter = {};

  mouseEmitter.mouseMove = new Signal();

  mouseEmitter.mouseDown = new Signal();

  mouseEmitter.mouseUp = new Signal();

  mouseEmitter.mouseClick = new Signal();

  mouseEmitter.mouseOut = new Signal();

  mouseEmitter.mouseOver = new Signal();

  mouseEmitter.mouseWheel = new Signal();

  mouseEmitter["_getMousePos"] = function(e) {
    if (e.clientX || e.clientY) {
      e.mouseX = e.clientX;
      e.mouseY = e.clientY;
    } else if (e.offsetX || e.offsetY) {
      e.mouseX = e.offsetX;
      e.mouseY = e.offsetY;
    }
    return [e.mouseX, e.mouseY];
  };

  makeMouseEmitter = function(obj) {
    var f, g,
      _this = this;
    if (obj.canvas != null) {
      util.extend(obj, mouseEmitter);
      obj.canvas.onmousemove = function(event) {
        obj._getMousePos(event);
        return obj.mouseMove.dispatch(event);
      };
      obj.canvas.onmousedown = function(event) {
        obj._getMousePos(event);
        return obj.mouseDown.dispatch(event);
      };
      obj.canvas.onmouseup = function(event) {
        obj._getMousePos(event);
        return obj.mouseUp.dispatch(event);
      };
      obj.canvas.onmouseclick = function(event) {
        obj._getMousePos(event);
        return obj.mouseClick.dispatch(event);
      };
      obj.canvas.onmouseout = function(event) {
        obj._getMousePos(event);
        return obj.mouseOut.dispatch(event);
      };
      obj.canvas.onmouseover = function(event) {
        obj._getMousePos(event);
        return obj.mouseOver.dispatch(event);
      };
      if (obj.canvas.addEventListener != null) {
        f = function(event) {
          obj._getMousePos(event);
          return obj.mouseWheel.dispatch(event);
        };
        g = function(event) {
          event.wheelDelta = Math.max(-500, Math.min(500, (event.wheelDelta || -event.detail) * 500));
          obj._getMousePos(event);
          return obj.mouseWheel.dispatch(event);
        };
        obj.canvas.addEventListener("mousewheel", f, false);
        return obj.canvas.addEventListener("DOMMouseScroll", g, false);
      } else {
        if (obj.canvas.onmousewheel != null) {
          return obj.canvas.onmousewheel = function(event) {
            obj._getMousePos(event);
            return obj.mouseWheel.dispatch(event);
          };
        }
      }
    }
  };

  /*TouchEmitter
  */


  touchEmitter = {};

  touchEmitter.touchPinch = new Signal();

  touchEmitter.touchTap = new Signal();

  touchEmitter.touchSpread = new Signal();

  touchEmitter.touchSwipe = new Signal();

  touchEmitter.ongoingTouches = [];

  makeTouchEmitter = function(obj) {
    var end, ongoingTouchIndexById,
      _this = this;
    if (obj.canvas != null) {
      util.extend(obj, touchEmitter);
      ongoingTouchIndexById = function(idToFind) {
        var i, id, touch, _i, _ref;
        if (obj.ongoingTouches.length > 0) {
          for (i = _i = 0, _ref = obj.ongoingTouches.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            touch = obj.ongoingTouches[i];
            id = touch.identifier;
            if (id === idToFind) {
              return i;
            }
          }
        }
        return -1;
      };
      obj.canvas.ontouchstart = function(evt) {
        var idx, touch, touches, _i, _len;
        evt.preventDefault();
        touches = evt.changedTouches;
        for (_i = 0, _len = touches.length; _i < _len; _i++) {
          touch = touches[_i];
          idx = ongoingTouchIndexById(touch.identifier);
          if (idx === -1) {
            touch.ppos = new Vec2(touch.clientX, touch.clientY);
            touch.cpos = new Vec2(touch.clientX, touch.clientY);
            touch.spos = new Vec2(touch.clientX, touch.clientY);
            touch.moved = false;
            obj.ongoingTouches.push(touch);
          }
        }
        if (CoffeeGL.Context.debug) {
          return console.log("Touch Start ", obj.ongoingTouches);
        }
      };
      obj.canvas.ontouchmove = function(evt) {
        var d0, d1, idx, newtouch, touch, touches, _i, _len;
        evt.preventDefault();
        touches = evt.changedTouches;
        for (_i = 0, _len = touches.length; _i < _len; _i++) {
          newtouch = touches[_i];
          idx = ongoingTouchIndexById(newtouch.identifier);
          touch = obj.ongoingTouches[idx];
          touch.moved = true;
          touch.ppos.x = touch.cpos.x;
          touch.ppos.y = touch.cpos.y;
          touch.cpos.x = newtouch.clientX;
          touch.cpos.y = newtouch.clientY;
        }
        if (obj.ongoingTouches.length === 2) {
          d0 = obj.ongoingTouches[0].cpos.dist(obj.ongoingTouches[1].cpos);
          d1 = obj.ongoingTouches[0].ppos.dist(obj.ongoingTouches[1].ppos);
          evt.ddist = d0 - d1;
          if (d0 > d1) {
            return obj.touchSpread.dispatch(evt);
          } else {
            return obj.touchPinch.dispatch(evt);
          }
        } else if (obj.ongoingTouches.length === 1) {
          evt.currentPos = obj.ongoingTouches[0].cpos;
          evt.previousPos = obj.ongoingTouches[0].ppos;
          evt.fingers = 1;
          return obj.touchSwipe.dispatch(evt);
        }
      };
      end = function(evt) {
        var idx, newtouch, touches, _i, _len;
        evt.preventDefault();
        touches = evt.changedTouches;
        for (_i = 0, _len = touches.length; _i < _len; _i++) {
          newtouch = touches[_i];
          idx = ongoingTouchIndexById(newtouch.identifier);
          if (newtouch.moved === false) {
            obj.touchTap.dispatch(evt);
          }
          while (idx !== -1) {
            obj.ongoingTouches.splice(idx, 1);
            idx = ongoingTouchIndexById(newtouch.identifier);
          }
        }
        if (CoffeeGL.Context.debug) {
          return console.log("Touch End ", obj.ongoingTouches);
        }
      };
      obj.canvas.ontouchend = end;
      return obj.canvas.ontouchcancel = end;
    }
  };

  module.exports = {
    Signal: Signal,
    makeMouseEmitter: makeMouseEmitter,
    makeTouchEmitter: makeTouchEmitter
  };

}).call(this);

},{"./util":2,"./math":3}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT 
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


TODO - updating the pos and the matrix together :S tricksy
*/


(function() {
  var Matrix4, PointLight, RGB, RGBA, Vec2, Vec3, Vec4, _ref, _ref1;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  _ref1 = require('./colour'), RGB = _ref1.RGB, RGBA = _ref1.RGBA;

  /* PointLight
  */


  PointLight = (function() {

    function PointLight(pos, colour, specular, attenuation) {
      this.pos = pos;
      this.colour = colour;
      this.specular = specular;
      this.attenuation = attenuation;
      if (this.pos == null) {
        this.pos = new Vec3(1, 1, 1);
      }
      if (this.colour == null) {
        this.colour = RGB.WHITE();
      }
      if (this.specular == null) {
        this.specular = RGB.WHITE();
      }
      if (this.attenuation == null) {
        this.attenuation = 0.99;
      }
      this.shadow_casting = false;
    }

    PointLight.prototype._addToNode = function(node) {
      node.pointLights.push(this);
      node.numPointLights = node.pointLights.length;
      return this;
    };

    PointLight.prototype._removeFromNode = function(node) {
      node.pointLights.splice(node.pointLights.indexOf(this));
      node.numPointLights = node.pointLights.length;
      return this;
    };

    return PointLight;

  })();

  module.exports = {
    PointLight: PointLight
  };

}).call(this);

},{"./math":3,"./colour":5}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details
*/


(function() {
  var Material, RGB, RGBA, _ref;

  _ref = require("./colour"), RGB = _ref.RGB, RGBA = _ref.RGBA;

  /*Material
  */


  Material = (function() {

    function Material(ambient, diffuse, specular, shine, emissive) {
      this.ambient = ambient;
      this.diffuse = diffuse;
      this.specular = specular;
      this.shine = shine;
      this.emissive = emissive;
      if (this.ambient == null) {
        this.ambient = new RGB(0, 0, 0);
      }
      if (this.diffuse == null) {
        this.diffuse = new RGB(1.0, 1.0, 1.0);
      }
      if (this.specular == null) {
        this.specular = new RGB(1.0, 1.0, 1.0);
      }
      if (this.shine == null) {
        this.shine = 20.0;
      }
      if (this.emissive == null) {
        this.emissive = new RGB(0.0, 0.0, 0.0);
      }
    }

    Material.prototype._addToNode = function(node) {
      return node.material = this;
    };

    return Material;

  })();

  module.exports = {
    Material: Material
  };

}).call(this);

},{"./colour":5}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details
*/


(function() {
  var Matrix4, Vec2, Vec3, Vec4, precomputeTangent, rayCircleIntersection, rayPlaneIntersect, _precomputeTangent, _ref;

  _ref = require('./math'), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4;

  /* rayPlaneIntersect
  */


  rayPlaneIntersect = function(plane_point, plane_normal, line_point, line_dir) {
    var den, num;
    num = Vec3.dot(plane_normal, Vec3.sub(plane_point, line_point));
    den = Vec3.dot(plane_normal, line_dir);
    return num / den;
  };

  /* precomputeTangent
  */


  precomputeTangent = function(a, b, c, na, nb, nc, ta, tb, tc) {
    return [_precomputeTangent(a, b, c, na, ta, tb, tc), _precomputeTangent(b, c, a, nb, tb, tc, ta), _precomputeTangent(c, a, b, nc, tc, ta, tb)];
  };

  _precomputeTangent = function(a, b, c, n, ta, tb, tc) {
    var alpha, binormal, binormal2, d, e, f, g, tangent, tx, ty, tz, ux, uy, uz;
    d = Vec3.sub(b, a);
    e = Vec3.sub(c, a);
    f = Vec2.sub(tb, ta);
    g = Vec2.sub(tc, ta);
    alpha = 1 / ((f.x * g.y) - (f.y * g.x));
    tx = alpha * (g.y * d.x + -f.y * e.x);
    ty = alpha * (g.y * d.y + -f.y * e.y);
    tz = alpha * (g.y * d.z + -f.y * e.z);
    ux = alpha * (-g.x * d.x + f.x * e.x);
    uy = alpha * (-g.x * d.y + f.x * e.y);
    uz = alpha * (-g.x * d.z + f.x * e.z);
    tangent = new Vec3(tx, ty, tz);
    binormal = new Vec3(ux, uy, uz);
    tangent = tangent.sub(Vec3.multScalar(n, Vec3.dot(n, tangent)));
    binormal2 = binormal.sub(Vec3.multScalar(n, Vec3.dot(n, binormal)));
    binormal2 = binormal2.sub(Vec3.multScalar(tangent, Vec3.dot(tangent, binormal)));
    tangent.normalize();
    binormal2.normalize();
    return tangent;
  };

  /* rayCircleIntersection
  */


  rayCircleIntersection = function(ray_start, ray_dir, circle_centre, circle_radius) {
    var a, b, c, d2, discriminant, f, r, t, t1, t2, v;
    f = CoffeeGL.Vec2.sub(ray_start, circle_centre);
    r = circle_radius;
    a = ray_dir.dot(ray_dir);
    b = 2 * f.dot(ray_dir);
    c = f.dot(f) - r * r;
    v = new CoffeeGL.Vec2();
    discriminant = b * b - 4 * a * c;
    if (discriminant !== 0) {
      discriminant = Math.sqrt(discriminant);
      t1 = (-b - discriminant) / (2 * a);
      t2 = (-b + discriminant) / (2 * a);
      t = t2;
      if (t2 < 0) {
        t = t1;
      }
      v.copyFrom(ray_start);
      d2 = CoffeeGL.Vec2.multScalar(ray_dir, t);
      v.add(d2);
    }
    return v;
  };

  module.exports = {
    rayPlaneIntersect: rayPlaneIntersect,
    rayCircleIntersection: rayCircleIntersection,
    precomputeTangent: precomputeTangent
  };

}).call(this);

},{"./math":3}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details

 * TODO
  - Many forms of interpolation - provide an optional function here (S curves etc)
*/


(function() {
  var CoffeeGLWarning, Interpolation, Matrix4, RGB, RGBA, Vec2, Vec3, Vec4, _ref, _ref1;

  _ref = require('./math'), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4;

  _ref1 = require('./colour'), RGB = _ref1.RGB, RGBA = _ref1.RGBA;

  CoffeeGLWarning = require('./error').CoffeeGLWarning;

  /* Interpolation
  */


  Interpolation = (function() {

    function Interpolation(obj0, obj1) {
      this.obj0 = obj0;
      this.obj1 = obj1;
      if (typeof this.obj0 === 'object') {
        if (this.obj0.__proto__ !== this.obj1.__proto__) {
          CoffeeGLWarning("Interpolating two different objects");
        }
      }
      if (this.obj0 instanceof Vec2) {
        this._set = this._setVec2;
      } else if (this.obj0 instanceof Vec3) {
        this._set = this._setVec3;
      } else if (this.obj0 instanceof Vec4) {
        this._set = this._setVec4;
      } else if (this.obj0 instanceof RGB) {
        this._set = this._setRGB;
      } else if (this.obj0 instanceof RGBA) {
        this._set = this._setRGBA;
      } else if (typeof obj0 === 'number') {
        this._set = this._setScalar;
      }
      this._value = 0;
    }

    Interpolation.prototype.set = function(val) {
      this._value = val;
      return this._set();
    };

    Interpolation.prototype._setVec2 = function() {
      return new Vec2(this.obj0.x + ((this.obj.x - this.obj0.x) * this._value), this.obj0.y + ((this.obj1.y - this.obj0.y) * this._value));
    };

    Interpolation.prototype._setVec3 = function() {
      return new Vec3(this.obj0.x + ((this.obj1.x - this.obj0.x) * this._value), this.obj0.y + ((this.obj1.y - this.obj0.y) * this._value), this.obj0.z + ((this.obj1.z - this.obj0.z) * this._value));
    };

    Interpolation.prototype._setVec4 = function() {
      return new Vec4(this.obj0.x + ((this.obj1.x - this.obj0.x) * this._value), this.obj0.y + ((this.obj1.y - this.obj0.y) * this._value), this.obj0.z + ((this.obj1.z - this.obj0.z) * this._value), this.obj0.w + ((this.obj1.w - this.obj0.w) * this._value));
    };

    Interpolation.prototype._setRGB = function() {
      return new RGB(this.obj0.r + ((this.obj1.r - this.obj0.r) * this._value), this.obj0.g + ((this.obj1.g - this.obj0.g) * this._value), this.obj0.b + ((this.obj1.b - this.obj0.b) * this._value));
    };

    Interpolation.prototype._setRGBA = function() {
      return new RGBA(this.obj0.r + ((this.obj1.r - this.obj0.r) * this._value), this.obj0.g + ((this.obj1.g - this.obj0.g) * this._value), this.obj0.b + ((this.obj1.b - this.obj0.b) * this._value), this.obj0.a + ((this.obj1.a - this.obj0.a) * this._value));
    };

    Interpolation.prototype._setScalar = function() {
      return this.obj0 + ((this.obj1 - this.obj0) * this._value);
    };

    return Interpolation;

  })();

  module.exports = {
    Interpolation: Interpolation
  };

}).call(this);

},{"./math":3,"./colour":5,"./error":19}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var glEnumToString, glEnums, glFunctionArgToString, glValidEnumContexts, initDebugContext, makeDebugContext, mightBeEnum;

  glValidEnumContexts = {
    'enable': {
      0: true
    },
    'disable': {
      0: true
    },
    'getParameter': {
      0: true
    },
    'drawArrays': {
      0: true
    },
    'drawElements': {
      0: true,
      2: true
    },
    'createShader': {
      0: true
    },
    'getShaderParameter': {
      1: true
    },
    'getProgramParameter': {
      1: true
    },
    'getVertexAttrib': {
      1: true
    },
    'vertexAttribPointer': {
      2: true
    },
    'bindTexture': {
      0: true
    },
    'activeTexture': {
      0: true
    },
    'getTexParameter': {
      0: true,
      1: true
    },
    'texParameterf': {
      0: true,
      1: true
    },
    'texParameteri': {
      0: true,
      1: true,
      2: true
    },
    'texImage2D': {
      0: true,
      2: true,
      6: true,
      7: true
    },
    'texSubImage2D': {
      0: true,
      6: true,
      7: true
    },
    'copyTexImage2D': {
      0: true,
      2: true
    },
    'copyTexSubImage2D': {
      0: true
    },
    'generateMipmap': {
      0: true
    },
    'bindBuffer': {
      0: true
    },
    'bufferData': {
      0: true,
      2: true
    },
    'bufferSubData': {
      0: true
    },
    'getBufferParameter': {
      0: true,
      1: true
    },
    'pixelStorei': {
      0: true,
      1: true
    },
    'readPixels': {
      4: true,
      5: true
    },
    'bindRenderbuffer': {
      0: true
    },
    'bindFramebuffer': {
      0: true
    },
    'checkFramebufferStatus': {
      0: true
    },
    'framebufferRenderbuffer': {
      0: true,
      1: true,
      2: true
    },
    'framebufferTexture2D': {
      0: true,
      1: true,
      2: true
    },
    'getFramebufferAttachmentParameter': {
      0: true,
      1: true,
      2: true
    },
    'getRenderbufferParameter': {
      0: true,
      1: true
    },
    'renderbufferStorage': {
      0: true,
      1: true
    },
    'clear': {
      0: true
    },
    'depthFunc': {
      0: true
    },
    'blendFunc': {
      0: true,
      1: true
    },
    'blendFuncSeparate': {
      0: true,
      1: true,
      2: true,
      3: true
    },
    'blendEquation': {
      0: true
    },
    'blendEquationSeparate': {
      0: true,
      1: true
    },
    'stencilFunc': {
      0: true
    },
    'stencilFuncSeparate': {
      0: true,
      1: true
    },
    'stencilMaskSeparate': {
      0: true
    },
    'stencilOp': {
      0: true,
      1: true,
      2: true
    },
    'stencilOpSeparate': {
      0: true,
      1: true,
      2: true,
      3: true
    },
    'cullFace': {
      0: true
    },
    'frontFace': {
      0: true
    }
  };

  glEnums = null;

  initDebugContext = function(ctx) {
    var propertyName, _i, _len, _results;
    if (glEnums === null) {
      glEnums = {};
      _results = [];
      for (_i = 0, _len = ctx.length; _i < _len; _i++) {
        propertyName = ctx[_i];
        if (typeof ctx[propertyName] === 'number') {
          _results.push(glEnums[ctx[propertyName]] = propertyName);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  mightBeEnum = function(value) {
    return glEnums[value] !== void 0;
  };

  glEnumToString = function(value) {
    var name, _ref;
    checkInit();
    name = glEnums[value];
    return (_ref = name !== void 0) != null ? _ref : {
      name: "*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")"
    };
  };

  glFunctionArgToString = function(functionName, argumentIndex, value) {
    var funcInfo;
    funcInfo = glValidEnumContexts[functionName];
    if (funcInfo !== void 0) {
      if (funcInfo[argumentIndex]) {
        return glEnumToString(value);
      }
    }
    return value.toString();
  };

  makeDebugContext = function(ctx) {
    return initDebugContext(ctx);
  };

}).call(this);

},{}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


Library of Shader functions
- TODO 
  * Load in snippets externally for this uber shader lib
  * Possibly add a vertex_main or similar to setup things? - 
    YES! Missing setting varyings is a pain in the ass! ><
*/


/*ShaderLibrary
*/


(function() {
  var ShaderLibrary;

  ShaderLibrary = (function() {

    function ShaderLibrary() {}

    ShaderLibrary.Basic = {
      vertex: "attribute vec3 aVertexPosition;uniform mat4 uModelMatrix;",
      fragment: ""
    };

    ShaderLibrary.VertexColour = {
      vertex: "attribute vec4 aVertexColour; varying vec4 vColour;",
      fragment: "varying vec4 vColour;"
    };

    ShaderLibrary.VertexTexCoord = {
      vertex: "attribute vec2 aVertexTexCoord; varying vec2 vTexCoord;",
      fragment: "varying vec2 vTexCoord;"
    };

    ShaderLibrary.BasicCamera = {
      vertex: "uniform mat4 uCameraMatrix; uniform mat4 uCameraInverseMatrix; uniform mat4 uProjectionMatrix;",
      fragment: ""
    };

    ShaderLibrary.VertexNormal = {
      vertex: "attribute vec3 aVertexNormal;varying vec3 vNormal;uniform mat3 uNormalMatrix;",
      fragment: "varying vec3 vNormal;"
    };

    ShaderLibrary.BasicMaterial = {
      vertex: "",
      fragment: "uniform vec3 uMaterialAmbientColor;uniform vec3 uMaterialDiffuseColor;uniform vec3 uMaterialSpecularColor;uniform float uMaterialShininess;uniform vec3 uMaterialEmissiveColor;"
    };

    ShaderLibrary.VertexTangent = {
      vertex: "attribute vec3 aVertexTangent;varying vec3 vTangent;",
      fragment: "varying vec3 vTangent;"
    };

    return ShaderLibrary;

  })();

  module.exports = {
    ShaderLibrary: ShaderLibrary
  };

}).call(this);

},{}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT 
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


TODO - updating the pos and the matrix together :S tricksy
*/


(function() {
  var Matrix4, PointLight, RGB, RGBA, Vec2, Vec3, Vec4, _ref, _ref1;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  _ref1 = require('./colour'), RGB = _ref1.RGB, RGBA = _ref1.RGBA;

  /* PointLight
  */


  PointLight = (function() {

    function PointLight(pos, colour, specular, attenuation) {
      this.pos = pos;
      this.colour = colour;
      this.specular = specular;
      this.attenuation = attenuation;
      if (this.pos == null) {
        this.pos = new Vec3(1, 1, 1);
      }
      if (this.colour == null) {
        this.colour = RGB.WHITE();
      }
      if (this.specular == null) {
        this.specular = RGB.WHITE();
      }
      if (this.attenuation == null) {
        this.attenuation = 0.99;
      }
      this.shadow_casting = false;
    }

    PointLight.prototype._addToNode = function(node) {
      node.pointLights.push(this);
      node.numPointLights = node.pointLights.length;
      return this;
    };

    PointLight.prototype._removeFromNode = function(node) {
      node.pointLights.splice(node.pointLights.indexOf(this));
      node.numPointLights = node.pointLights.length;
      return this;
    };

    return PointLight;

  })();

  module.exports = {
    PointLight: PointLight
  };

}).call(this);

},{"./math":3,"./colour":5}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


- Resources

- TODO
  * Load Items should make a guess at the filesize of the thing they are loading
*/


(function() {
  var LoadItem, LoadQueue, Signal;

  Signal = require('./signal').Signal;

  /*LoadItem
  */


  LoadItem = (function() {

    function LoadItem(func) {
      this.func = func;
    }

    LoadItem.prototype.loaded = function() {
      return this.loader.itemCompleted(this);
    };

    return LoadItem;

  })();

  /*LoadQueue
  */


  LoadQueue = (function() {

    function LoadQueue(obj, onLoaded, onFinish) {
      this.obj = obj;
      this.onLoaded = onLoaded;
      this.onFinish = onFinish;
      this.items = [];
      this.completed_items = [];
      this.complete = new CoffeeGL.Signal();
      if (this.onFinish != null) {
        this.complete.add(onFinish, this);
      }
      this;
    }

    LoadQueue.prototype.itemCompleted = function(item) {
      this.completed_items.push(item);
      if (this.onLoaded != null) {
        this.onLoaded();
      }
      if (this.completed_items.length === this.items.length) {
        this.complete.dispatch();
      }
      return this;
    };

    LoadQueue.prototype.add = function(item) {
      item.obj = this.obj;
      item.loader = this;
      this.items.push(item);
      return this;
    };

    LoadQueue.prototype.start = function() {
      var item, _i, _len, _ref;
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.func();
      }
      return this;
    };

    return LoadQueue;

  })();

  module.exports = {
    LoadItem: LoadItem,
    LoadQueue: LoadQueue
  };

}).call(this);

},{"./signal":16}]},{},[1])
;