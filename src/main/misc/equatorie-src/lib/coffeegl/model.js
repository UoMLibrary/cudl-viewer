// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/

A mesh is a collection of triangles with or without indices.
All the triangles should have the same kinds of vertices 

- TODO
  * We split on materials at present. We should split on meshes if possible but
    not sure if the three.js supports that. For example, normal map and diffuse
    textures per mesh. Double check the three standard

  * There are texture loads in here. We need to set their callbacks and have a signal
    in here for when everything completes as 

JSONModel is a node that creates geometries below it which are also nodes
These geometries are drawn seperatly, each with their own material  
Accepts three.js style json model format
*/


(function() {
  var CoffeeGLWarning, JSONModel, LoadItem, LoadQueue, Material, Matrix4, Node, Quad, RGB, RGBA, Request, Signal, Texture, Triangle, TriangleMesh, Vec2, Vec3, Vec4, Vertex, _ref, _ref1, _ref2, _ref3,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./primitives'), Triangle = _ref.Triangle, Quad = _ref.Quad, Vertex = _ref.Vertex, TriangleMesh = _ref.TriangleMesh;

  Node = require('./node').Node;

  _ref1 = require('./math'), Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, Vec4 = _ref1.Vec4, Matrix4 = _ref1.Matrix4;

  Material = require('./material').Material;

  _ref2 = require('./colour'), RGB = _ref2.RGB, RGBA = _ref2.RGBA;

  Texture = require('./texture').Texture;

  Request = require('./request').Request;

  Signal = require('./signal').Signal;

  CoffeeGLWarning = require('./error').CoffeeGLWarning;

  _ref3 = require('./loader'), LoadItem = _ref3.LoadItem, LoadQueue = _ref3.LoadQueue;

  /*JSONModel
  */


  JSONModel = (function(_super) {

    __extends(JSONModel, _super);

    JSONModel.prototype._bitset = function(value, position) {
      return value & (1 << position);
    };

    function JSONModel(json_data, params) {
      var cc, closure_parse, colourAmbient, colourDiffuse, colourSpecular, i, materials, model, n, path, specularCoef, tf, url, _i, _ref4,
        _this = this;
      this.params = params;
      this._parse = function(json_data) {
        return JSONModel.prototype._parse.apply(_this, arguments);
      };
      JSONModel.__super__.constructor.call(this);
      if (this.params == null) {
        this.params = {};
        this.params.texturing = true;
      } else {
        if (this.params.texturing == null) {
          this.params.texturing = true;
        }
      }
      this.queue = new LoadQueue(this, this.params.onItem, this.params.onLoad);
      materials = json_data["materials"];
      if (materials.length === 0) {
        this.add(new Node(new TriangleMesh(true)));
      } else {
        for (i = _i = 0, _ref4 = materials.length - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
          n = new Node();
          this.add(n);
          if (json_data["materials"][i]["DbgName"] != null) {
            n.dbgName = json_data["materials"][i]["DbgName"];
          }
          if (json_data["materials"][i]["DbgName"] === "default" || json_data["materials"][i]["DbgIndex"] === 1) {
            n.add(new Material());
          } else {
            colourAmbient = new RGB(json_data["materials"][i]["colorAmbient"][0], json_data["materials"][i]["colorAmbient"][1], json_data["materials"][i]["colorAmbient"][2]);
            if (colourAmbient == null) {
              colourAmbient = RGB.WHITE();
            }
            colourDiffuse = new RGB(json_data["materials"][i]["colorDiffuse"][0], json_data["materials"][i]["colorDiffuse"][1], json_data["materials"][i]["colorDiffuse"][2]);
            if (colourDiffuse == null) {
              colourDiffuse = RGB.WHITE();
            }
            colourSpecular = new RGB(json_data["materials"][i]["colorSpecular"][0], json_data["materials"][i]["colorSpecular"][1], json_data["materials"][i]["colorSpecular"][2]);
            if (colourSpecular == null) {
              colourSpecular = RGB.WHITE();
            }
            specularCoef = json_data["materials"][i]["specularCoef"];
            n.add(new Material(colourAmbient, colourDiffuse, colourSpecular, specularCoef));
          }
          n.geometry = new TriangleMesh(true);
          if (this.params.texturing) {
            if ((json_data["materials"][i]["mapDiffuse"] != null) && (json_data._coffeegl_request_url != null)) {
              url = json_data._coffeegl_request_url.substring(0, json_data._coffeegl_request_url.lastIndexOf("/"));
              path = url + "/" + json_data["materials"][i]["mapDiffuse"];
              cc = CoffeeGL.Context;
              tf = new LoadItem((function(n, path) {
                var _cc, _n, _path;
                _n = n;
                _path = path;
                _cc = cc;
                return function() {
                  var t,
                    _this = this;
                  CoffeeGL.Context.switchContext(_cc);
                  return t = new Texture(_path, {}, function() {
                    _n.add(t);
                    _this.loaded();
                    return _this;
                  });
                };
                return this;
              })(n, path));
              this.queue.add(tf);
            }
          }
        }
      }
      cc = CoffeeGL.Context;
      model = this;
      closure_parse = (function(n, model) {
        var data, _cc, _model,
          _this = this;
        data = json_data;
        _model = model;
        _cc = cc;
        return function() {
          CoffeeGL.Context.switchContext(_cc);
          return _model._parse(data);
        };
      })(n, model);
      this.queue.add(new LoadItem(function() {
        closure_parse();
        return this.loaded();
      }));
      this.queue.start();
    }

    JSONModel.prototype._parse = function(json_data) {
      var child, cidx, i, i0, i1, i2, i3, midx, nidx, node_idx, prim, removals, type, type2, uvidx, vertices, vi0, vi1, vi2, vi3, vidx, _i, _j, _len, _len1, _ref4;
      node_idx = 0;
      vidx = 0;
      vertices = [];
      while (vidx < json_data["vertices"].length) {
        vertices.push(new Vertex(new Vec3(json_data["vertices"][vidx++], json_data["vertices"][vidx++], json_data["vertices"][vidx++])));
      }
      i = 0;
      while (i < json_data["faces"].length) {
        type = json_data["faces"][i++];
        prim;
        vi0;
        vi1;
        vi2;
        vi3;
        midx = {
          id: 0,
          type: -1
        };
        if (this._bitset(type, 0)) {
          vi0 = json_data["faces"][i++];
          vi1 = json_data["faces"][i++];
          vi2 = json_data["faces"][i++];
          vi3 = json_data["faces"][i++];
          prim = new Quad(vertices[vi0], vertices[vi1], vertices[vi2], vertices[vi3]);
        } else {
          vi0 = json_data["faces"][i++];
          vi1 = json_data["faces"][i++];
          vi2 = json_data["faces"][i++];
          prim = new Triangle(vertices[vi0], vertices[vi1], vertices[vi2]);
        }
        if (this._bitset(type, 1)) {
          midx.id = json_data["faces"][i++];
          type2 = type | 1;
          if (midx.type === -1) {
            midx.type = type2;
          } else {
            if (type2 !== midx.type) {
              CoffeeGLWarning("Different types within the same material");
            }
          }
        }
        if (this._bitset(type, 2)) {
          uvidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 3)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
            vertices[vi3].t = new Vec2(json_data["uvs"][0][i3 * 2], json_data["uvs"][0][i3 * 2 + 1]);
          }
          vertices[vi0].t = new Vec2(json_data["uvs"][0][i0 * 2], json_data["uvs"][0][i0 * 2 + 1]);
          vertices[vi1].t = new Vec2(json_data["uvs"][0][i1 * 2], json_data["uvs"][0][i1 * 2 + 1]);
          vertices[vi2].t = new Vec2(json_data["uvs"][0][i2 * 2], json_data["uvs"][0][i2 * 2 + 1]);
        }
        if (this._bitset(type, 4)) {
          nidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 5)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
            vertices[vi3].n = new Vec3(json_data["normals"][i3 * 3], json_data["normals"][i3 * 3 + 1], json_data["normals"][i3 * 3 + 2]);
          }
          vertices[vi0].n = new Vec3(json_data["normals"][i0 * 3], json_data["normals"][i0 * 3 + 1], json_data["normals"][i0 * 3 + 2]);
          vertices[vi1].n = new Vec3(json_data["normals"][i1 * 3], json_data["normals"][i1 * 3 + 1], json_data["normals"][i1 * 3 + 2]);
          vertices[vi2].n = new Vec3(json_data["normals"][i2 * 3], json_data["normals"][i2 * 3 + 1], json_data["normals"][i2 * 3 + 2]);
        }
        if (this._bitset(type, 6)) {
          cidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 7)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
          }
        }
        if (prim instanceof Triangle) {
          this.children[midx.id].geometry.addTriangle(prim);
        } else {
          this.children[midx.id].geometry.addQuad(prim);
        }
      }
      removals = [];
      _ref4 = this.children;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        child = _ref4[_i];
        if (child.geometry != null) {
          if (child.geometry.v.length === 0) {
            removals.push(child);
          }
        }
      }
      for (_j = 0, _len1 = removals.length; _j < _len1; _j++) {
        child = removals[_j];
        this.remove(child);
      }
      return this;
    };

    return JSONModel;

  })(Node);

  module.exports = {
    JSONModel: JSONModel
  };

}).call(this);
