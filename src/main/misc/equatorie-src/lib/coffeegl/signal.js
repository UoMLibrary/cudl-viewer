// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details



# There is no hierarchy or bubbling really. Anyone can listen

- TODO
  * Drag, double click etc
  * inbuilt dx,dy
  * Is there some kind of signals lib for Coffeescript? Like the signals in JS?

Influenced by signals.js - an object where listeners and events may be added
*/


(function() {
  var Signal, Vec2, makeMouseEmitter, makeTouchEmitter, mouseEmitter, touchEmitter, util;

  util = require("./util");

  Vec2 = require("./math").Vec2;

  /*Signal
  */


  Signal = (function() {

    function Signal() {
      this.listeners = [];
    }

    Signal.prototype.add = function(func, context) {
      this.listeners.push({
        f: func,
        c: context,
        o: false,
        g: CoffeeGL.Context
      });
      return this;
    };

    Signal.prototype.addOnce = function(func, context) {
      this.listeners.push({
        f: func,
        c: context,
        o: true,
        g: CoffeeGL.Context
      });
      return this;
    };

    Signal.prototype.remove = function(func, context) {
      this.del(func);
      return this;
    };

    Signal.prototype.del = function(func, context) {
      var i, obj, _i, _len, _ref;
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj.c === context) {
          if (obj.f === func) {
            i = this.listeners.indexOf(obj);
            this.listeners.splice(i, 1);
            break;
          }
        }
      }
      return this;
    };

    Signal.prototype.dispatch = function() {
      var l, removals, _i, _j, _len, _len1, _ref;
      removals = [];
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        CoffeeGL.Context.switchContext(l.g);
        l.f.apply(l.c, arguments);
        if (l.o) {
          removals.push(l);
        }
      }
      for (_j = 0, _len1 = removals.length; _j < _len1; _j++) {
        l = removals[_j];
        this.del(l);
      }
      return this;
    };

    return Signal;

  })();

  /*MouseEmitter
  */


  mouseEmitter = {};

  mouseEmitter["_setEvent"] = function(event) {
    this._getMousePos(event);
    this._setButtons(event);
    if (event.preventDefault != null) {
      event.preventDefault();
    }
    if (event.stopImmediatePropagation != null) {
      event.stopImmediatePropagation();
    }
    if (event.stopPropagation != null) {
      event.stopPropagation();
    }
    return event;
  };

  mouseEmitter["_getMousePos"] = function(e) {
    if (e.clientX || e.clientY) {
      e.mouseX = e.clientX;
      e.mouseY = e.clientY;
    } else if (e.offsetX || e.offsetY) {
      e.mouseX = e.offsetX;
      e.mouseY = e.offsetY;
    }
    return [e.mouseX, e.mouseY];
  };

  mouseEmitter["_setButtons"] = function(event) {
    if (event.type === "mousedown") {
      this._mouseButton = true;
    } else if (event.type === "mouseup" || event.type === "mouseout") {
      this._mouseButton = false;
    }
    if (CoffeeGL.Context.profile.browser === "Firefox") {
      if (event.type === "mousemove" && event.buttons !== 0) {
        this._mouseButton = true;
      }
    }
    if (this._mouseButton) {
      if (CoffeeGL.Context.profile.browser === "Firefox") {
        if ((event.button === 0 && event.buttons === 1) || event.buttons === 1) {
          event.buttonLeft = true;
          event.buttonMiddle = false;
          event.buttonRight = false;
          return event;
        } else if ((event.button === 1 && event.buttons === 4) || event.buttons === 4) {
          event.buttonLeft = false;
          event.buttonMiddle = true;
          event.buttonRight = false;
          return event;
        } else if ((event.button === 2 && event.buttons === 2) || event.buttons === 2) {
          event.buttonLeft = false;
          event.buttonMiddle = false;
          event.buttonRight = true;
          return event;
        }
      } else {
        if (event.button === 0) {
          event.buttonLeft = true;
          event.buttonMiddle = false;
          event.buttonRight = false;
          return event;
        } else if (event.button === 1) {
          event.buttonLeft = false;
          event.buttonMiddle = true;
          event.buttonRight = false;
          return event;
        } else if (event.button === 2) {
          event.buttonLeft = false;
          event.buttonMiddle = false;
          event.buttonRight = true;
          return event;
        }
      }
    } else {
      event.buttonLeft = false;
      event.buttonMiddle = false;
      event.buttonRight = false;
      return event;
    }
  };

  makeMouseEmitter = function(obj) {
    var f, g, q,
      _this = this;
    if (obj.canvas != null) {
      util.extend(obj, mouseEmitter);
      obj.mouseMove = new Signal();
      obj.mouseDown = new Signal();
      obj.mouseUp = new Signal();
      obj.mouseClick = new Signal();
      obj.mouseOut = new Signal();
      obj.mouseOver = new Signal();
      obj.mouseWheel = new Signal();
      obj["_mouseButton"] = false;
      obj.canvas.onmousemove = function(event) {
        var e;
        CoffeeGL.Context.switchContext(obj);
        e = obj._setEvent(event);
        obj.mouseMove.dispatch(e);
        return false;
      };
      obj.canvas.onmousedown = function(event) {
        CoffeeGL.Context.switchContext(obj);
        obj._setEvent(event);
        obj.mouseDown.dispatch(event);
        return false;
      };
      obj.canvas.onmouseup = function(event) {
        CoffeeGL.Context.switchContext(obj);
        obj._setEvent(event);
        obj.mouseUp.dispatch(event);
        return false;
      };
      obj.canvas.onmouseclick = function(event) {
        CoffeeGL.Context.switchContext(obj);
        obj._setEvent(event);
        obj.mouseClick.dispatch(event);
        return false;
      };
      obj.canvas.oncontextmenu = function(event) {
        CoffeeGL.Context.switchContext(obj);
        obj._setEvent(event);
        return false;
      };
      obj.canvas.onmouseout = function(event) {
        CoffeeGL.Context.switchContext(obj);
        obj._setEvent(event);
        obj.mouseOut.dispatch(event);
        return false;
      };
      obj.canvas.onmouseover = function(event) {
        CoffeeGL.Context.switchContext(obj);
        obj._setEvent(event);
        obj.mouseOver.dispatch(event);
        return false;
      };
      if (obj.canvas.addEventListener != null) {
        f = function(event) {
          CoffeeGL.Context.switchContext(obj);
          obj._setEvent(event);
          obj.mouseWheel.dispatch(event);
          return false;
        };
        g = function(event) {
          CoffeeGL.Context.switchContext(obj);
          event.wheelDelta = Math.max(-500, Math.min(500, (event.wheelDelta || -event.detail) * 500));
          obj._setEvent(event);
          obj.mouseWheel.dispatch(event);
          return false;
        };
        q = function(event) {
          CoffeeGL.Context.switchContext(obj);
          obj._setEvent(event);
          obj.mouseClick.dispatch(event);
          return false;
        };
        obj.canvas.addEventListener("mousewheel", f, false);
        obj.canvas.addEventListener("DOMMouseScroll", g, false);
        return obj.canvas.addEventListener("mouseclick", q, false);
      } else {
        if (obj.canvas.onmousewheel != null) {
          return obj.canvas.onmousewheel = function(event) {
            CoffeeGL.Context.switchContext(obj);
            obj._setEvent(event);
            obj.mouseWheel.dispatch(event);
            return false;
          };
        }
      }
    }
  };

  /*TouchEmitter
  */


  touchEmitter = {};

  makeTouchEmitter = function(obj) {
    var end, ongoingTouchIndexById,
      _this = this;
    if (obj.canvas != null) {
      util.extend(obj, touchEmitter);
      obj.touchPinch = new Signal();
      obj.touchTap = new Signal();
      obj.touchSpread = new Signal();
      obj.touchSwipe = new Signal();
      obj.ongoingTouches = [];
      ongoingTouchIndexById = function(idToFind) {
        var i, id, touch, _i, _ref;
        CoffeeGL.Context.switchContext(obj);
        if (obj.ongoingTouches.length > 0) {
          for (i = _i = 0, _ref = obj.ongoingTouches.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            touch = obj.ongoingTouches[i];
            id = touch.identifier;
            if (id === idToFind) {
              return i;
            }
          }
        }
        return -1;
      };
      obj.canvas.ontouchstart = function(evt) {
        var idx, touch, touches, _i, _len;
        CoffeeGL.Context.switchContext(obj);
        evt.preventDefault();
        touches = evt.changedTouches;
        for (_i = 0, _len = touches.length; _i < _len; _i++) {
          touch = touches[_i];
          idx = ongoingTouchIndexById(touch.identifier);
          if (idx === -1) {
            touch.ppos = new Vec2(touch.clientX, touch.clientY);
            touch.cpos = new Vec2(touch.clientX, touch.clientY);
            touch.spos = new Vec2(touch.clientX, touch.clientY);
            touch.moved = false;
            obj.ongoingTouches.push(touch);
          }
        }
        if (CoffeeGL.Context.debug) {
          return console.log("Touch Start ", obj.ongoingTouches);
        }
      };
      obj.canvas.ontouchmove = function(evt) {
        var cosa, d0, d1, dd0, dd1, idx, newtouch, touch, touches, _i, _len;
        CoffeeGL.Context.switchContext(obj);
        evt.preventDefault();
        touches = evt.changedTouches;
        for (_i = 0, _len = touches.length; _i < _len; _i++) {
          newtouch = touches[_i];
          idx = ongoingTouchIndexById(newtouch.identifier);
          touch = obj.ongoingTouches[idx];
          touch.moved = true;
          touch.ppos.x = touch.cpos.x;
          touch.ppos.y = touch.cpos.y;
          touch.cpos.x = newtouch.clientX;
          touch.cpos.y = newtouch.clientY;
        }
        if (obj.ongoingTouches.length === 2) {
          d0 = obj.ongoingTouches[0].cpos.dist(obj.ongoingTouches[1].cpos);
          d1 = obj.ongoingTouches[0].ppos.dist(obj.ongoingTouches[1].ppos);
          evt.ddist = d0 - d1;
          dd0 = Vec2.sub(obj.ongoingTouches[0].cpos, obj.ongoingTouches[0].ppos);
          dd1 = Vec2.sub(obj.ongoingTouches[1].cpos, obj.ongoingTouches[1].ppos);
          cosa = dd0.dot(dd1) / (dd0.length() * dd1.length());
          if (cosa > 0.5) {
            evt.currentPos = obj.ongoingTouches[0].cpos;
            evt.previousPos = obj.ongoingTouches[0].ppos;
            evt.fingers = 2;
            return obj.touchSwipe.dispatch(evt);
          } else {
            if (d0 > d1) {
              return obj.touchSpread.dispatch(evt);
            } else {
              return obj.touchPinch.dispatch(evt);
            }
          }
        } else if (obj.ongoingTouches.length === 1) {
          evt.currentPos = obj.ongoingTouches[0].cpos;
          evt.previousPos = obj.ongoingTouches[0].ppos;
          evt.fingers = 1;
          return obj.touchSwipe.dispatch(evt);
        }
      };
      end = function(evt) {
        var idx, newtouch, touches, _i, _len;
        CoffeeGL.Context.switchContext(obj);
        evt.preventDefault();
        touches = evt.changedTouches;
        for (_i = 0, _len = touches.length; _i < _len; _i++) {
          newtouch = touches[_i];
          idx = ongoingTouchIndexById(newtouch.identifier);
          if (newtouch.moved === false) {
            obj.touchTap.dispatch(evt);
          }
          while (idx !== -1) {
            obj.ongoingTouches.splice(idx, 1);
            idx = ongoingTouchIndexById(newtouch.identifier);
          }
        }
        if (CoffeeGL.Context.debug) {
          return console.log("Touch End ", obj.ongoingTouches);
        }
      };
      obj.canvas.ontouchend = end;
      return obj.canvas.ontouchcancel = end;
    }
  };

  module.exports = {
    Signal: Signal,
    makeMouseEmitter: makeMouseEmitter,
    makeTouchEmitter: makeTouchEmitter
  };

}).call(this);
