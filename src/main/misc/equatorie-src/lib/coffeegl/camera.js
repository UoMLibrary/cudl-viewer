// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details



- TODO
  * TEST ORTHO CAMERA! I dont think it works! ><
  * update isnt really that great :S Keep it internal :)
  * functions to change the positions so we can change things like look pos and
    have the up vector change accordingly

https://gist.github.com/eligrey/384583 - useful for changes to pos,look etc?
*/


(function() {
  var Camera, Matrix4, MousePerspCamera, OrthoCamera, PerspCamera, Primitive, Quaternion, TouchPerspCamera, Vec2, Vec3, Vec4, degToRad, makeMouseListener, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./math'), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4, Quaternion = _ref.Quaternion, degToRad = _ref.degToRad;

  Primitive = require('./primitives').Primitive;

  makeMouseListener = require('./signal').makeMouseListener;

  /* Camera
  */


  Camera = (function() {

    function Camera(pos, look, up) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      if (this.pos == null) {
        this.pos = new Vec3(0, 0, 5);
      }
      if (this.look == null) {
        this.look = new Vec3(0, 0, 0);
      }
      if (this.up == null) {
        this.up = new Vec3(0, 1, 0);
      }
      this.m = new Matrix4();
      this.p = new Matrix4();
      this.i = new Matrix4();
      this.q = new Quaternion();
    }

    Camera.prototype.update = function() {
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    Camera.prototype.orbit = function(axis, angle) {
      var dir, l;
      this.q.fromAxisAngle(axis, angle);
      dir = Vec3.sub(this.look, this.pos);
      dir.normalize();
      l = Vec3.sub(this.pos, this.look);
      this.q.transVec3(l);
      this.q.transVec3(this.up);
      l.add(this.look);
      this.pos.copyFrom(l);
      return this.update();
    };

    Camera.prototype.pantilt = function(axis, angle) {
      var dir, q2;
      this.q.fromAxisAngle(axis, angle);
      dir = Vec3.sub(this.look, this.pos);
      dir.normalize();
      q2 = new Quaternion();
      q2.fromAxisAngle(Vec3.cross(dir, this.up), angle);
      q2.mult(this.q);
      q2.transVec3(this.look);
      q2.transVec3(this.up);
      return this.update();
    };

    Camera.prototype._addToNode = function(node) {
      node.camera = this;
      return this;
    };

    Camera.prototype.track = function(v) {
      var g;
      g = new Vec4(v.x, v.y, 0, 0);
      this.i.multVec(g);
      this.look.add(g);
      this.pos.add(g);
      return this;
    };

    return Camera;

  })();

  /* OrthoCamera
  */


  OrthoCamera = (function(_super) {

    __extends(OrthoCamera, _super);

    function OrthoCamera(pos, look, up, near, far) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.near = near;
      this.far = far;
      OrthoCamera.__super__.constructor.call(this, this.pos, this.look, this.up);
      if (this.near == null) {
        this.near = -1.0;
      }
      if (this.far == null) {
        this.far = 1.0;
      }
    }

    OrthoCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      OrthoCamera.__super__.update.call(this);
      this.p.makeOrtho(-1, 1, -1, 1, this.near, this.far);
      return this;
    };

    return OrthoCamera;

  })(Camera);

  /* PerspCamera
  */


  PerspCamera = (function(_super) {

    __extends(PerspCamera, _super);

    function PerspCamera(pos, look, up, angle, near, far) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      PerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up);
      if (this.angle == null) {
        this.angle = 50.0;
      }
      if (this.near == null) {
        this.near = 0.1;
      }
      if (this.far == null) {
        this.far = 100.0;
      }
      this.zoom_near = this.near;
      this.zoom_far = this.far;
    }

    PerspCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      PerspCamera.__super__.update.call(this);
      this.p.makePerspective(this.angle, w / h, this.near, this.far);
      return this;
    };

    PerspCamera.prototype.castRay = function(sx, sy) {
      var g, gl, pp;
      if (CoffeeGL.Context != null) {
        gl = CoffeeGL.Context.gl;
        g = new Vec4((sx * 2) / CoffeeGL.Context.width - 1, 1 - (sy * 2) / CoffeeGL.Context.height, 1.0, 1.0);
        pp = Matrix4.mult(Matrix4.invert(this.m), Matrix4.invert(this.p));
        pp.multVec(g);
        g.normalize();
        return new Vec3(g.x, g.y, g.z);
      }
      return new Vec3(0, 0, 0);
    };

    PerspCamera.prototype._zoom = function(dt) {
      var dir, dl, dp, tl;
      dir = Vec3.sub(this.look, this.pos);
      dl = dir.length();
      tl = this.zoom_far - this.zoom_near;
      dp = dl / tl;
      this.zoom(dp + dt);
      return this;
    };

    PerspCamera.prototype.zoom = function(z) {
      var dir, tl;
      if (z > 0 && z < 1) {
        dir = Vec3.sub(this.pos, this.look);
        dir.normalize();
        tl = this.zoom_far - this.zoom_near;
        dir.multScalar(z * tl);
        this.pos = Vec3.add(this.look, dir);
        this.update();
      }
      return this;
    };

    return PerspCamera;

  })(Camera);

  /* MousePerspCamera
  */


  MousePerspCamera = (function(_super) {

    __extends(MousePerspCamera, _super);

    function MousePerspCamera(pos, look, up, angle, near, far, sense) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      this.sense = sense;
      MousePerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up, this.angle, this.near, this.far);
      CoffeeGL.Context.mouseMove.add(this.onMouseMove, this);
      CoffeeGL.Context.mouseDown.add(this.onMouseDown, this);
      CoffeeGL.Context.mouseUp.add(this.onMouseUp, this);
      CoffeeGL.Context.mouseWheel.add(this.onMouseWheel, this);
      if (this.sense == null) {
        this.sense = 0.3;
      }
      this.px = 0;
      this.py = 0;
      this.dx = 0;
      this.dy = 0;
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      this;
    }

    MousePerspCamera.prototype.onMouseMove = function(event) {
      var dir, x, y;
      x = event.mouseX;
      y = event.mouseY;
      this.dx = x - this.px;
      this.px = x;
      this.dy = y - this.py;
      this.py = y;
      if (event.buttonLeft) {
        this.orbit(new Vec3(0, 1, 0), degToRad(-this.dx * this.sense));
        dir = Vec3.sub(this.look, this.pos);
        this.orbit(Vec3.cross(dir, this.up), degToRad(this.dy * this.sense));
      } else if (event.buttonRight) {
        this.track(new Vec2(this.dx * this.sense * -0.02, this.dy * this.sense * 0.02));
      }
      return this;
    };

    MousePerspCamera.prototype.onMouseDown = function(event) {
      var x, y;
      x = event.mouseX;
      y = event.mouseY;
      this.px = x;
      this.py = y;
      this.dx = 0;
      this.dy = 0;
      return this;
    };

    MousePerspCamera.prototype.onMouseUp = function(event) {
      return this;
    };

    MousePerspCamera.prototype.onMouseWheel = function(event) {
      var dp, dt, tl;
      dt = event.wheelDelta * 0.01 * this.sense;
      tl = this.far - this.near;
      dp = dt / tl;
      this._zoom(dp);
      return this;
    };

    MousePerspCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      this.p.makePerspective(this.angle, w / h, this.near, this.far);
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    MousePerspCamera.prototype.onMouseOut = function(event) {
      this.px = 0;
      this.py = 0;
      this.dx = 0;
      return this.dy = 0;
    };

    MousePerspCamera.prototype.onMouseOver = function(event) {
      var _ref1;
      if (this.px === 0 && this.py === 0) {
        return _ref1 = [event.mouseX, event.mouseY], this.px = _ref1[0], this.py = _ref1[1], _ref1;
      }
    };

    return MousePerspCamera;

  })(PerspCamera);

  /* TouchPerspCamera
  */


  TouchPerspCamera = (function(_super) {

    __extends(TouchPerspCamera, _super);

    function TouchPerspCamera(pos, look, up, angle, near, far, sense) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      this.sense = sense;
      TouchPerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up, this.angle, this.near, this.far);
      CoffeeGL.Context.touchPinch.add(this.onPinch, this);
      CoffeeGL.Context.touchSpread.add(this.onSpread, this);
      CoffeeGL.Context.touchSwipe.add(this.onSwipe, this);
    }

    TouchPerspCamera.prototype.onPinch = function(event) {
      var dp, dt, tl;
      dt = -event.ddist * 0.08 * this.sense;
      tl = this.far - this.near;
      dp = dt / tl;
      this._zoom(dp);
      return this;
    };

    TouchPerspCamera.prototype.onSpread = function(event) {
      var dp, dt, tl;
      dt = -event.ddist * 0.08 * this.sense;
      tl = this.far - this.near;
      dp = dt / tl;
      this._zoom(dp);
      return this;
    };

    TouchPerspCamera.prototype.onSwipe = function(event) {
      var dir, x, y;
      x = event.currentPos.x;
      y = event.currentPos.y;
      this.px = event.previousPos.x;
      this.py = event.previousPos.y;
      this.dx = x - this.px;
      this.px = x;
      this.dy = y - this.py;
      this.py = y;
      if (event.fingers === 1) {
        this.orbit(new Vec3(0, 1, 0), degToRad(-this.dx * this.sense));
        dir = Vec3.sub(this.look, this.pos);
        this.orbit(Vec3.cross(dir, this.up), degToRad(-this.dy * this.sense));
      } else if (event.fingers === 2) {
        this.track(new Vec2(this.dx * this.sense * -0.02, this.dy * this.sense * 0.02));
      }
      return this;
    };

    return TouchPerspCamera;

  })(MousePerspCamera);

  module.exports = {
    Camera: Camera,
    OrthoCamera: OrthoCamera,
    PerspCamera: PerspCamera,
    MousePerspCamera: MousePerspCamera,
    TouchPerspCamera: TouchPerspCamera
  };

}).call(this);
