// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


The WebGL End of our basic primitives. Here we match our classes to the WebGL Shaders 
and buffers

 - TODO
  * Geometry may or may not have more buffers (should we wish to add them)
  * Do we put in face duplication here? I.e, if we want to pass in per face details
    we need to change the buffers
  * It appears that bufferSubData isnt the thing to use but is this true? (for updateing)
  * Geometry that has changed totally? Delete and redo buffers is needed
  * Per Face Brew method - I.e duplicate vertices if there is per-face data specified in
    the brew parameters
*/


(function() {
  var CoffeeGLWarning, CoffeeGLWarningOnce, Cuboid, Matrix4, Quad, RGB, RGBA, Sphere, Triangle, TriangleMesh, Vec2, Vec3, Vertex, WebGLNodeDrawable, brew, createArrayBuffer, createElementBuffer, deleteBuffer, drawGeometryGL, makeNodeDrawableGL, setDataBuffer, util, washup, _attribTypeCheckSet, _matchWithShader, _ref, _ref1, _ref2, _ref3, _ref4, _splitRole, _typeCheckSet;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec3 = _ref.Vec3, Vec2 = _ref.Vec2;

  _ref1 = require('./colour'), RGB = _ref1.RGB, RGBA = _ref1.RGBA;

  _ref2 = require('./primitives'), Vertex = _ref2.Vertex, Triangle = _ref2.Triangle, Quad = _ref2.Quad, TriangleMesh = _ref2.TriangleMesh;

  _ref3 = require('./shapes'), Cuboid = _ref3.Cuboid, Sphere = _ref3.Sphere;

  _ref4 = require('./error'), CoffeeGLWarning = _ref4.CoffeeGLWarning, CoffeeGLWarningOnce = _ref4.CoffeeGLWarningOnce;

  util = require("./util");

  /* setDataBuffer
  */


  setDataBuffer = function(buffer, data, type) {
    var gl;
    gl = CoffeeGL.Context.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, type);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
  };

  /* createArrayBuffer
  */


  createArrayBuffer = function(data, type, size) {
    var buffer, gl;
    gl = CoffeeGL.Context.gl;
    buffer = gl.createBuffer();
    setDataBuffer(buffer, data, type);
    buffer.itemSize = size;
    buffer.numItems = data.length / size;
    return buffer;
  };

  /* createElementBuffer
  */


  createElementBuffer = function(data, type, size) {
    var buffer, gl;
    gl = CoffeeGL.Context.gl;
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, type);
    buffer.itemSize = size;
    buffer.numItems = data.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
  };

  /* deleteBuffer
  */


  deleteBuffer = function(buffer) {
    var gl;
    gl = CoffeeGL.Context.gl;
    gl.deleteBuffer(buffer);
    return this;
  };

  /* _attribTypeCheckSet
  */


  _attribTypeCheckSet = function(a, v) {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (a.pos === -1) {
      return;
    }
    gl.enableVertexAttribArray(a.pos);
    gl.bindBuffer(gl.ARRAY_BUFFER, v[a.role]);
    if (a.type === "int") {
      gl.vertexAttribPointer(a.pos, 1, gl.INT, false, 0, 0);
    } else if (a.type === "float") {
      gl.vertexAttribPointer(a.pos, 1, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec2") {
      gl.vertexAttribPointer(a.pos, 2, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec3") {
      gl.vertexAttribPointer(a.pos, 3, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec4") {
      gl.vertexAttribPointer(a.pos, 4, gl.FLOAT, false, 0, 0);
    }
    return this;
  };

  /* _typeCheckSet
  */


  _typeCheckSet = function(u, v, tag) {
    var gl, idx, m, role, t, x, _i, _j, _k, _len, _len1, _len2, _ref5, _ref6, _ref7;
    if (u.pos === -1) {
      return;
    }
    role = u.role;
    if (tag != null) {
      role = _splitRole(tag, u.role);
    }
    gl = CoffeeGL.Context.gl;
    if (u.size === 1) {
      if (u.type === "float") {
        gl.uniform1f(u.pos, v[role]);
      } else if (u.type === "int") {
        gl.uniform1i(u.pos, v[role]);
      } else if (u.type === "vec2") {
        gl.uniform2f(u.pos, v[role].x, v[role].y);
      } else if (u.type === "vec3") {
        if (v[role].x != null) {
          gl.uniform3f(u.pos, v[role].x, v[role].y, v[role].z);
        } else {
          gl.uniform3f(u.pos, v[role].r, v[role].g, v[role].b);
        }
      } else if (u.type === "vec4") {
        if (v[role].x != null) {
          gl.uniform4f(u.pos, v[role].x, v[role].y, v[role].z, v[role].w);
        } else {
          gl.uniform4f(u.pos, v[role].r, v[role].g, v[role].b, v[role].a);
        }
      } else if (u.type === "mat4") {
        gl.uniformMatrix4fv(u.pos, false, v[role].a);
      } else if (u.type === "mat3") {
        gl.uniformMatrix3fv(u.pos, false, v[role].a);
      } else if (u.type === "sampler2D") {
        gl.uniform1i(u.pos, v[role]);
      }
    } else {
      if (v[role][0] instanceof Object) {
        t = [];
        if (v[role][0].flatten != null) {
          _ref5 = v[role];
          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
            x = _ref5[_i];
            t = t.concat(x.flatten());
          }
          if (u.type === "vec2") {
            gl.uniform2fv(u.pos, new Float32Array(t));
          } else if (u.type === "vec3") {
            gl.uniform3fv(u.pos, new Float32Array(t));
          } else if (u.type === "vec4") {
            gl.uniform4fv(u.pos, new Float32Array(t));
          }
        } else if (v[role][0].a) {
          if (u.type === "mat3") {
            t = new Float32Array(9 * v[role].length);
            idx = 0;
            _ref6 = v[role];
            for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
              m = _ref6[_j];
              t.set(m.a, idx * 9);
              idx++;
            }
            gl.uniformMatrix3fv(u.pos, false, new Float32Array(t));
          } else if (u.type === "mat4") {
            t = new Float32Array(16 * v[role].length);
            idx = 0;
            _ref7 = v[role];
            for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
              m = _ref7[_k];
              t.set(m.a, idx * 16);
              idx++;
            }
            gl.uniformMatrix4fv(u.pos, false, new Float32Array(t));
          }
        }
      } else {
        if (u.type === "float") {
          gl.uniform1fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "int") {
          gl.uniform1iv(u.pos, new Int32Array(v[role]));
        } else if (u.type === "vec2") {
          gl.uniform2fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "vec3") {
          gl.uniform3fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "vec4") {
          gl.uniform4fv(u.pos, new Float32Array(v[role]));
        } else if (u.type === "mat4") {
          gl.uniformMatrix4fv(u.pos, false, new Float32Array(v[role]));
        }
      }
    }
    return this;
  };

  /* _splitRole
  */


  _splitRole = function(tag, role) {
    if (role.indexOf(tag) !== -1) {
      return role.split("/")[1];
    }
    return role;
  };

  /* _matchWithShader
  */


  _matchWithShader = function(node) {
    var a, attenuations, colours, contract, light, pointlights, positions, shader, speculars, t, u, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref10, _ref11, _ref12, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (CoffeeGL.Context.shader == null) {
      console.log("CoffeeGL Error - Not Shader bound when calling _matchWithShader");
      return node;
    }
    if (CoffeeGL.Context.shader.contract == null) {
      console.log("CoffeeGL Error - Not Shader contract when calling _matchWithShader");
      return node;
    }
    contract = CoffeeGL.Context.shader.contract;
    shader = CoffeeGL.Context.shader;
    _ref5 = contract.uniforms;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      u = _ref5[_i];
      if (node[u.role] != null) {
        _typeCheckSet(u, node);
      }
    }
    if (node._camera != null) {
      _ref6 = contract.uniforms;
      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
        u = _ref6[_j];
        if (node._camera[_splitRole("camera", u.role)] != null) {
          _typeCheckSet(u, node._camera, "camera");
        }
      }
    }
    if (node._material != null) {
      _ref7 = contract.uniforms;
      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
        u = _ref7[_k];
        if (node._material[_splitRole("material", u.role)] != null) {
          _typeCheckSet(u, node._material, "material");
        }
      }
    }
    if (node._pointLightsGlobal.length > 0) {
      positions = [];
      colours = [];
      speculars = [];
      attenuations = [];
      _ref8 = node._pointLightsGlobal;
      for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
        light = _ref8[_l];
        positions = positions.concat(light.pos.flatten());
        colours = colours.concat(light.colour.flatten());
        speculars = speculars.concat(light.specular.flatten());
        attenuations.push(light.attenuation);
      }
      positions = new Float32Array(positions);
      colours = new Float32Array(colours);
      speculars = new Float32Array(speculars);
      attenuations = new Float32Array(attenuations);
      pointlights = {
        pos: positions,
        colour: colours,
        specular: speculars,
        attenuations: attenuations
      };
      _ref9 = contract.uniforms;
      for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
        u = _ref9[_m];
        if (pointlights[_splitRole("pointlight", u.role)] != null) {
          _typeCheckSet(u, pointlights, "pointlight");
        }
      }
    }
    if (node.textures != null) {
      _ref10 = contract.textures;
      for (_n = 0, _len5 = _ref10.length; _n < _len5; _n++) {
        u = _ref10[_n];
        _ref11 = node.textures;
        for (_o = 0, _len6 = _ref11.length; _o < _len6; _o++) {
          t = _ref11[_o];
          if (t[_splitRole("texture", u.role)] != null) {
            _typeCheckSet(u, t, "texture");
          }
        }
      }
    }
    if (node.geometry != null) {
      _ref12 = contract.attributes;
      for (_p = 0, _len7 = _ref12.length; _p < _len7; _p++) {
        a = _ref12[_p];
        if (node.geometry[a.role] != null) {
          _attribTypeCheckSet(a, node.geometry);
        }
      }
    }
    return node;
  };

  /* drawGeometryGL
  */


  drawGeometryGL = function(geometry, drawPrimitive) {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (drawPrimitive == null) {
      if (geometry.layout == null) {
        drawPrimitive = gl.TRIANGLES;
      } else {
        if (geometry.layout === "TRIANGLE_STRIP") {
          drawPrimitive = gl.TRIANGLE_STRIP;
        } else if (geometry.layout === "POINTS") {
          drawPrimitive = gl.POINTS;
        } else {
          drawPrimitive = gl.TRIANGLES;
        }
      }
    }
    if (geometry.vertexIndexBuffer != null) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.vertexIndexBuffer);
      return gl.drawElements(drawPrimitive, geometry.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    } else {
      return gl.drawArrays(drawPrimitive, 0, geometry.vertexPositionBuffer.numItems);
    }
  };

  /* brew
  */


  brew = function(geometry, params) {
    var access, colours, gl, normals, size, tangents, uvs, v, vertices, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref5, _ref6, _ref7, _ref8, _ref9;
    if ((geometry.v == null) || geometry.v.length <= 0) {
      geometry.brewed = false;
      return this;
    }
    gl = CoffeeGL.Context.gl;
    if (params == null) {
      params = {};
    }
    vertices = [];
    _ref5 = geometry.v;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      v = _ref5[_i];
      vertices = vertices.concat(v.p.flatten());
    }
    access = params.position_buffer_access != null ? params.position_buffer_access : gl.STATIC_DRAW;
    if (geometry.vertexPositionBuffer == null) {
      geometry.vertexPositionBuffer = createArrayBuffer(new Float32Array(vertices), access, 3);
    } else {
      if (v.length === geometry.vertexPositionBuffer.numItems) {
        setDataBuffer(geometry.vertexPositionBuffer, new Float32Array(vertices), access);
      } else {
        CoffeeGLWarningOnce("Attemping to update position buffer of different length");
      }
    }
    if (geometry.v[0].c != null) {
      access = params.colour_buffer_access != null ? params.colour_buffer_access : gl.STATIC_DRAW;
      colours = [];
      _ref6 = geometry.v;
      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
        v = _ref6[_j];
        colours = colours.concat(v.c.flatten());
      }
      if (!geometry.vertexColourBuffer) {
        size = 4;
        if (geometry.v[0].c instanceof RGB) {
          size = 3;
        }
        geometry.vertexColourBuffer = createArrayBuffer(new Float32Array(colours), access, size);
      } else {
        if (v.length === geometry.vertexColourBuffer.numItems) {
          setDataBuffer(geometry.vertexColourBuffer, new Float32Array(colours), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update colour buffer of different length");
        }
      }
    }
    if (geometry.indices != null) {
      access = params.indices_buffer_access != null ? params.indices_buffer_access : gl.STATIC_DRAW;
      if (geometry.vertexIndexBuffer == null) {
        geometry.vertexIndexBuffer = createElementBuffer(new Uint16Array(geometry.indices), access, 1);
      } else {
        if (v.length === geometry.vertexIndexBuffer.numItems) {
          setDataBuffer(geometry.vertexIndexBuffer, new Float32Array(geometry.indices), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update indices buffer of different length");
        }
      }
    }
    if (geometry.v[0].n != null) {
      normals = [];
      access = params.normal_buffer_access != null ? params.normal_buffer_access : gl.STATIC_DRAW;
      _ref7 = geometry.v;
      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
        v = _ref7[_k];
        normals = normals.concat(v.n.flatten());
      }
      if (geometry.vertexNormalBuffer == null) {
        geometry.vertexNormalBuffer = createArrayBuffer(new Float32Array(normals), access, 3);
      } else {
        if (v.length === geometry.vertexNormalBuffer.numItems) {
          setDataBuffer(geometry.vertexNormalBuffer, new Float32Array(normals), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update normals buffer of different length");
        }
      }
    }
    if (geometry.v[0].t != null) {
      uvs = [];
      access = params.texcoord_buffer_access != null ? params.texcoord_buffer_access : gl.STATIC_DRAW;
      _ref8 = geometry.v;
      for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
        v = _ref8[_l];
        uvs = uvs.concat(v.t.flatten());
      }
      if (geometry.vertexTextureBuffer == null) {
        geometry.vertexTextureBuffer = createArrayBuffer(new Float32Array(uvs), access, 2);
      } else {
        if (v.length === geometry.vertexTextureBuffer.numItems) {
          setDataBuffer(geometry.vertexIndexBuffer, new Float32Array(uvs), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update texture co-ord buffer of different length");
        }
      }
    }
    if (geometry.v[0].tangent != null) {
      tangents = [];
      access = params.tangent_buffer_access != null ? params.tangent_buffer_access : gl.STATIC_DRAW;
      _ref9 = geometry.v;
      for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
        v = _ref9[_m];
        tangents = tangents.concat(v.tangent.flatten());
      }
      if (geometry.vertexTangentBuffer == null) {
        geometry.vertexTangentBuffer = createArrayBuffer(new Float32Array(tangents), access, 3);
      } else {
        if (v.length === geometry.vertexTangentBuffer.numItems) {
          setDataBuffer(geometry.vertexTangentBuffer, new Float32Array(tangents), access);
        } else {
          CoffeeGLWarningOnce("Attemping to update tangent buffer of different length");
        }
      }
    }
    geometry.brewed = true;
    return this;
  };

  washup = function(geometry) {
    return this;
  };

  /* WebGLNodeDrawable
  */


  WebGLNodeDrawable = {};

  WebGLNodeDrawable.drawGL = function() {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (this._shader != null) {
      CoffeeGL.Context.shader = this._shader;
    }
    if (CoffeeGL.Context.shader == null) {
      return this;
    }
    CoffeeGL.Context.shader.bind();
    _matchWithShader(this);
    if (this.geometry) {
      drawGeometryGL(this.geometry);
    }
    return this;
  };

  WebGLNodeDrawable.brew = function() {
    return brew(this.geometry);
  };

  makeNodeDrawableGL = function(node) {
    util.extend(node, WebGLNodeDrawable);
    if (node.geometry != null) {
      if (node.geometry.brewed == null) {
        node.geometry.brewed = false;
      }
    }
    return this;
  };

  module.exports = {
    makeNodeDrawableGL: makeNodeDrawableGL
  };

}).call(this);
