// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details
*/


(function() {
  var CoffeeGL, Cuboid, CurveCubic, Cylinder, Geometry, Node, PI, Quad, RGB, RGBA, Sphere, Triangle, Vec2, Vec3, Vertex, degToRad, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CoffeeGL = require('./coffeegl').CoffeeGL;

  Node = require('./node').Node;

  _ref = require('./colour'), RGB = _ref.RGB, RGBA = _ref.RGBA;

  _ref1 = require('./math'), Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, PI = _ref1.PI, degToRad = _ref1.degToRad;

  _ref2 = require('./primitives'), Vertex = _ref2.Vertex, Triangle = _ref2.Triangle, Quad = _ref2.Quad, Geometry = _ref2.Geometry;

  /*Cuboid
  */


  Cuboid = (function(_super) {

    __extends(Cuboid, _super);

    function Cuboid(dim, colour) {
      var d, h, i, w, _i, _ref3;
      Cuboid.__super__.constructor.call(this);
      if (dim == null) {
        dim = new Vec3(1.0, 1.0, 1.0);
      }
      w = dim.x / 2;
      h = dim.y / 2;
      d = dim.z / 2;
      this.v.push(new Vertex(new Vec3(-w, -h, d), colour, Vec3.normalize(new Vec3(-w, -h, d)), new Vec2(0, 0)));
      this.v.push(new Vertex(new Vec3(w, -h, d), colour, Vec3.normalize(new Vec3(w, -h, d)), new Vec2(1, 0)));
      this.v.push(new Vertex(new Vec3(w, h, d), colour, Vec3.normalize(new Vec3(w, h, d)), new Vec2(1, 1)));
      this.v.push(new Vertex(new Vec3(-w, h, d), colour, Vec3.normalize(new Vec3(-w, h, d)), new Vec2(0, 1)));
      this.v.push(new Vertex(new Vec3(-w, -h, -d), colour, Vec3.normalize(new Vec3(-w, -h, -d)), new Vec2(1, 1)));
      this.v.push(new Vertex(new Vec3(w, -h, -d), colour, Vec3.normalize(new Vec3(w, -h, -d)), new Vec2(1, 0)));
      this.v.push(new Vertex(new Vec3(w, h, -d), colour, Vec3.normalize(new Vec3(w, h, -d)), new Vec2(0, 0)));
      this.v.push(new Vertex(new Vec3(-w, h, -d), colour, Vec3.normalize(new Vec3(-w, h, -d)), new Vec2(0, 1)));
      this.indices = [0, 1, 2, 0, 2, 3, 6, 5, 4, 6, 4, 7, 4, 0, 3, 4, 3, 7, 1, 5, 2, 5, 6, 2, 3, 2, 6, 3, 6, 7, 4, 5, 1, 4, 1, 0];
      for (i = _i = 0, _ref3 = this.indices.length - 1; _i <= _ref3; i = _i += 3) {
        this.faces.push(new Triangle(this.v[this.indices[i]], this.v[this.indices[i + 1]], this.v[this.indices[i + 2]]));
      }
    }

    return Cuboid;

  })(Geometry);

  /*Sphere
  */


  Sphere = (function(_super) {

    __extends(Sphere, _super);

    function Sphere(radius, segments, center, colour) {
      var c, e, i, j, p, t, theta1, theta2, theta3, v, _i, _j, _k, _ref3, _ref4, _ref5;
      Sphere.__super__.constructor.call(this);
      this.layout = "TRIANGLE_STRIP";
      if (center == null) {
        center = new Vec3(0, 0, 0);
      }
      if (segments != null) {
        if (segments < 0) {
          segments = 10;
        }
      } else {
        segments = 10;
      }
      for (j = _i = 0, _ref3 = segments / 2; 0 <= _ref3 ? _i <= _ref3 : _i >= _ref3; j = 0 <= _ref3 ? ++_i : --_i) {
        theta1 = j * 2 * PI / segments - (PI / 2);
        theta2 = (j + 1) * 2 * PI / segments - (PI / 2);
        for (i = _j = 0, _ref4 = segments + 1; 0 <= _ref4 ? _j <= _ref4 : _j >= _ref4; i = 0 <= _ref4 ? ++_j : --_j) {
          e = new Vec3();
          theta3 = i * 2 * PI / segments;
          e.x = Math.cos(theta1) * Math.cos(theta3);
          e.y = Math.sin(theta1);
          e.z = Math.cos(theta1) * Math.sin(theta3);
          p = Vec3.multScalar(e, radius).add(center);
          c = new RGBA(1.0, 1.0, 1.0, 1.0);
          t = new Vec2(0.999 - i / segments, 0.999 - 2 * j / segments);
          v = new Vertex(p, c, e, t);
          this.v.push(v);
          e = new Vec3();
          e.x = Math.cos(theta2) * Math.cos(theta3);
          e.y = Math.sin(theta2);
          e.z = Math.cos(theta2) * Math.sin(theta3);
          p = Vec3.multScalar(e, radius).add(center);
          t = new Vec2(0.999 - i / segments, 0.999 - 2 * (j + 1) / segments);
          v = new Vertex(p, c, e, t);
          this.v.push(v);
        }
      }
      for (i = _k = 2, _ref5 = this.v.length - 1; _k <= _ref5; i = _k += 1) {
        if (i % 2 === 0) {
          this.faces.push(new Triangle(this.v[i], this.v[i - 1], this.v[i - 2]));
        } else {
          this.faces.push(new Triangle(this.v[i], this.v[i - 2], this.v[i - 1]));
        }
      }
    }

    return Sphere;

  })(Geometry);

  /*Cylinder
  */


  Cylinder = (function(_super) {

    __extends(Cylinder, _super);

    function Cylinder(radius, resolution, segments, height, colour) {
      var e, hstep, i, j, n, s, tangent, x, z, _i, _j, _k, _l, _m, _n, _o, _p, _ref3, _ref4, _ref5;
      Cylinder.__super__.constructor.call(this);
      this.indices = [];
      if (radius != null) {
        if (radius < 0) {
          radius = 0.5;
        }
      } else {
        radius = 0.5;
      }
      if (segments != null) {
        if (segments < 0) {
          segments = 10;
        }
      } else {
        segments = 10;
      }
      if (height != null) {
        if (height < 0) {
          height = 1.0;
        }
      } else {
        height = 1.0;
      }
      hstep = height / segments;
      height = height / 2.0;
      this.v.push(new Vertex(new Vec3(0, height, 0), colour, new Vec3(0, 1.0, 0.0), new Vec2(0.5, 0.0)));
      for (i = _i = 1; 1 <= resolution ? _i <= resolution : _i >= resolution; i = 1 <= resolution ? ++_i : --_i) {
        x = radius * Math.sin(degToRad(360.0 / resolution * i));
        z = radius * Math.cos(degToRad(360.0 / resolution * i));
        tangent = new Vec3(x, 0, z);
        tangent.normalize();
        tangent.cross(new Vec3(0, 1, 0));
        this.v.push(new Vertex(new Vec3(x, height, z), colour, Vec3.normalize(new Vec3(x, 1.0, z)), new Vec2(i / resolution, 0.0), tangent));
      }
      for (i = _j = 1; 1 <= resolution ? _j <= resolution : _j >= resolution; i = 1 <= resolution ? ++_j : --_j) {
        this.indices.push(0);
        this.indices.push(i);
        if (i === resolution) {
          this.indices.push(1);
        } else {
          this.indices.push(i + 1);
        }
      }
      for (i = _k = 1; 1 <= segments ? _k <= segments : _k >= segments; i = 1 <= segments ? ++_k : --_k) {
        for (j = _l = 1; 1 <= resolution ? _l <= resolution : _l >= resolution; j = 1 <= resolution ? ++_l : --_l) {
          x = radius * Math.sin(degToRad(360.0 / resolution * j));
          z = radius * Math.cos(degToRad(360.0 / resolution * j));
          tangent = new Vec3(x, 0, z);
          tangent.normalize();
          tangent.cross(new Vec3(0, -1, 0));
          n = Vec3.normalize(new Vec3(x, 0, z));
          if (i === segments) {
            n = Vec3.normalize(new Vec3(x, -1, z));
          }
          this.v.push(new Vertex(new Vec3(x, height - (hstep * i), z), colour, n, new Vec2(j / resolution, i / segments), tangent));
        }
        s = (i - 1) * resolution + 1;
        e = s + resolution;
        for (j = _m = 0, _ref3 = resolution - 1; 0 <= _ref3 ? _m <= _ref3 : _m >= _ref3; j = 0 <= _ref3 ? ++_m : --_m) {
          this.indices.push(s + j);
          this.indices.push(e + j);
          if (j === (resolution - 1)) {
            this.indices.push(e);
          } else {
            this.indices.push(e + j + 1);
          }
        }
        for (j = _n = 0, _ref4 = resolution - 1; 0 <= _ref4 ? _n <= _ref4 : _n >= _ref4; j = 0 <= _ref4 ? ++_n : --_n) {
          this.indices.push(s + j);
          if (j === (resolution - 1)) {
            this.indices.push(e);
            this.indices.push(s);
          } else {
            this.indices.push(e + j + 1);
            this.indices.push(s + j + 1);
          }
        }
      }
      this.v.push(new Vertex(new Vec3(0, -height, 0), colour, new Vec3(0, -1.0, 0.0), new Vec2(0.5, 1.0)));
      s = (segments * resolution) + 2;
      e = s + resolution - 1;
      for (i = _o = s; s <= e ? _o <= e : _o >= e; i = s <= e ? ++_o : --_o) {
        this.indices.push(s - 1);
        if (i === e) {
          this.indices.push(s);
        } else {
          this.indices.push(i + 1);
        }
        this.indices.push(i);
      }
      for (i = _p = 0, _ref5 = this.indices.length - 1; _p <= _ref5; i = _p += 3) {
        this.faces.push(new Triangle(this.v[this.indices[i]], this.v[this.indices[i + 1]], this.v[this.indices[i + 2]]));
      }
      this;
    }

    return Cylinder;

  })(Geometry);

  /*CurveCubic
  */


  CurveCubic = (function() {

    function CurveCubic(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }

    CurveCubic.prototype._B1 = function(t) {
      return t * t * t;
    };

    CurveCubic.prototype._B2 = function(t) {
      return 3 * t * t * (1 - t);
    };

    CurveCubic.prototype._B3 = function(t) {
      return 3 * t * (1 - t) * (1 - t);
    };

    CurveCubic.prototype._B4 = function(t) {
      return (1 - t) * (1 - t) * (1 - t);
    };

    CurveCubic.prototype.pointOnCurve = function(val) {
      return new Vector3(v0.x * this._B1(val) + v1.x * this._B2(val) + v2.x * this._B3(val) + v3.x * this._B4(val), v0.y * this._B1(val) + v1.y * this._B2(val) + v2.y * this._B3(val) + v3.y * this._B4(val), v0.z * this._B1(val) + v1.z * this._B2(val) + v2.z * this._B3(val) + v3.z * this._B4(val));
    };

    return CurveCubic;

  })();

  module.exports = {
    Cuboid: Cuboid,
    Sphere: Sphere,
    Cylinder: Cylinder,
    CurveCubic: CurveCubic
  };

}).call(this);
