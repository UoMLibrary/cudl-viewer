// Generated by CoffeeScript 1.6.1

/* ABOUT
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under the MIT Licence. See LICENCE.txt for details


Consists of a matrix, a material, parent and children for the scene graph computation
Doesnt have to be drawn per-se

If @geometry is attached, this node can be made drawable
If the node is made gldrawable, buffers will be attached to this node. The node then needs 
to be unbrewed.
*/


(function() {
  var Camera, Geometry, Material, Matrix3, Matrix4, Node, PointLight, Texture, Vec3, Vec4, makeNodeDrawableGL, util, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./math'), Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix3 = _ref.Matrix3, Matrix4 = _ref.Matrix4;

  makeNodeDrawableGL = require('./webgl').makeNodeDrawableGL;

  Camera = require('./camera').Camera;

  Material = require('./material').Material;

  Texture = require('./texture').Texture;

  PointLight = require('./Light').PointLight;

  Geometry = require('./primitives').Geometry;

  util = require('./util');

  /*Node
  */


  Node = (function() {

    function Node(geometry, material, textures, shader, pointLights) {
      this.geometry = geometry;
      this.material = material;
      this.textures = textures;
      this.shader = shader;
      this.pointLights = pointLights;
      this.matrix = new Matrix4();
      this._modelMatrix = new Matrix4();
      this._normalMatrix = new Matrix3();
      this.children = [];
      this.skip_draw = false;
      this.descend = true;
      if (this.pointLights == null) {
        this.pointLights = [];
        this.pointLightsGlobal = [];
        this.numPointLights = 0;
      }
      if (this.textures == null) {
        this.textures = [];
      }
    }

    Node.prototype.add = function(p) {
      if (typeof p._addToNode === "function") {
        p._addToNode(this);
      }
      return this;
    };

    Node.prototype.remove = function(p) {
      if (typeof p._removeFromNode === "function") {
        p._removeFromNode(this);
      }
      return this;
    };

    Node.prototype._addToNode = function(node) {
      node.children.push(this);
      return this;
    };

    Node.prototype.copy = function() {
      return util.clone(this);
    };

    Node.prototype.del = function(p) {
      var i;
      if (__indexOf.call(this.children, p) >= 0) {
        i = this.children.indexOf(p);
        this.children.splice(i, 1);
      }
      return this;
    };

    Node.prototype._removeFromNode = function(node) {
      node.del(this);
      return this;
    };

    Node.prototype.draw = function() {
      var front;
      front = {
        _modelMatrix: new Matrix4(),
        _pointLightsGlobal: [],
        _normalMatrix: new Matrix4(),
        _camera: void 0,
        _shader: void 0
      };
      return this._draw(this, front);
    };

    Node.prototype._draw = function(node, front) {
      var child, cloned, light, newlight, nm, tex, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4;
      _ref1 = node.textures;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tex = _ref1[_i];
        tex.bind();
      }
      front._modelMatrix = Matrix4.mult(front._modelMatrix, node.matrix);
      nm = node._modelMatrix.copy();
      front._normalMatrix = nm.invert().transpose().getMatrix3();
      if (node.pointLights != null) {
        _ref2 = node.pointLights;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          light = _ref2[_j];
          newlight = util.clone(light);
          front._modelMatrix.multVec(newlight.pos);
          front._pointLightsGlobal.push(newlight);
        }
        front._numPointLightsGlobal = front._pointLightsGlobal.length;
      }
      if (node.camera != null) {
        front._camera = node.camera;
      }
      front._shader = node.shader;
      if (node.material != null) {
        front._material = node.material;
      }
      if (node.drawGL == null) {
        makeNodeDrawableGL(node);
        if (node.geometry != null) {
          if (!node.geometry.brewed) {
            node.brew();
          }
        }
      }
      node = util.extend(node, front);
      if (!node.skip_draw) {
        node.drawGL();
      }
      if (node.descend) {
        _ref3 = node.children;
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          child = _ref3[_k];
          cloned = {
            _modelMatrix: new Matrix4(front._modelMatrix),
            _pointLightsGlobal: [],
            _normalMatrix: new Matrix4(),
            _camera: front._camera,
            _material: front._material,
            _shader: front._shader
          };
          cloned._pointLightsGlobal = cloned._pointLightsGlobal.concat(front._pointLightsGlobal);
          this._draw(child, cloned);
        }
      }
      _ref4 = node.textures;
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        tex = _ref4[_l];
        tex.unbind();
      }
      return node;
    };

    return Node;

  })();

  module.exports = {
    Node: Node
  };

}).call(this);
