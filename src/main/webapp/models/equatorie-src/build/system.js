// Generated by CoffeeScript 1.6.3
(function() {
  var CoffeeGL, EquatorieSystem;

  CoffeeGL = require('../lib/coffeegl/coffeegl').CoffeeGL;

  EquatorieSystem = (function() {
    function EquatorieSystem() {
      this.base_radius = 6.0;
      this.inch_to_base = 0.166666666667;
      this.epicycle_radius = 6.0;
      this.epicycle_thickness = 0.333334;
      this.precession = 0.00003838;
      this.moon_radius = 1.17742;
      this.planet_data = {};
      /*
      
      @planet_data.venus =
        deferent_speed : 0.98564734
        epicycle_speed : 0.61652156
        epicycle_ratio : 0.72294
        deferent_eccentricity : 0.0145
        apogee_longitude : 98.1666667
        mean_longitude : 279.7
        mean_anomaly : 63.383
      
      @planet_data.mars =
        deferent_speed : 0.52407116
        epicycle_speed : 0.46157618
        epicycle_ratio : 0.6563
        deferent_eccentricity : 0.10284
        apogee_longitude : 148.6166667
        mean_longitude : 293.55
        mean_anomaly : 346.15
      
      @planet_data.jupiter =
        deferent_speed : 0.08312944
        epicycle_speed : 0.90251790
        epicycle_ratio : 0.1922
        deferent_eccentricity : 0.04817
        apogee_longitude : 188.9666667
        mean_longitude : 238.16666667
        mean_anomaly : 41.5333333
      
       @planet_data.saturn =
        deferent_speed : 0.03349795
        epicycle_speed : 0.95214939
        epicycle_ratio : 0.10483
        deferent_eccentricity : 0.05318
        apogee_longitude : 270.76666667
        mean_longitude : 266.25
        mean_anomaly : 13.45
      */

      this.planet_data.venus = {
        deferent_speed: 0.9856464,
        epicycle_speed: 0.61652156,
        epicycle_ratio: 0.76639,
        deferent_eccentricity: 0.018056,
        apogee_longitude: 90.15,
        mean_longitude: 288.55,
        mean_anomaly: 23.216667
      };
      this.planet_data.mars = {
        deferent_speed: 0.52406791,
        epicycle_speed: 0.46157618,
        epicycle_ratio: 0.68611,
        deferent_eccentricity: 0.095,
        apogee_longitude: 133.93333,
        mean_longitude: 92.2,
        mean_anomaly: 196.33333
      };
      this.planet_data.jupiter = {
        deferent_speed: 0.08312709,
        epicycle_speed: 0.90251790,
        epicycle_ratio: 0.184167,
        deferent_eccentricity: 0.049583,
        apogee_longitude: 172.333,
        mean_longitude: 324.75,
        mean_anomaly: 323.78333
      };
      this.planet_data.saturn = {
        deferent_speed: 0.03349673,
        epicycle_speed: 0.95214939,
        epicycle_ratio: 0.10361,
        deferent_eccentricity: 0.0543056,
        apogee_longitude: 252.11666667,
        mean_longitude: 184.75,
        mean_anomaly: 103.78333
      };
      this.planet_data.mercury = {
        deferent_speed: 0.9856464,
        epicycle_speed: 3.10670237,
        epicycle_ratio: 0.36722,
        deferent_eccentricity: 0.05056,
        apogee_longitude: 209.7666666,
        mean_longitude: 288.55,
        mean_anomaly: 259.78333
      };
      this.planet_data.sun = {
        deferent_speed: 0.9856464,
        apogee_longitude: 90.15,
        mean_longitude: 288.55,
        equant_ratio: 1 / 32
      };
      this.planet_data.moon = {
        deferent_speed: 13.1763947,
        epicycle_speed: 13.0649885,
        epicycle_ratio: 0.08694,
        mean_longitude: 130.46666,
        mean_anomaly: 84.63333
      };
      this.planet_data.moon_latitude = this.planet_data.moon;
      this.planet_data.caput_draconis = {
        start_motus: 344.633333,
        speed: -0.05295426
      };
      this.epoch = new Date(1392, 11, 31);
      this.epoch.setHours(12);
      this.epoch_julian = 2229851;
      this.reset();
    }

    EquatorieSystem.prototype.solveForPlanetDate = function(planet, date) {
      var _ref;
      this._setPlanet(planet);
      this._calculateDate(date);
      _ref = this._calculateMeanMotusBody("sun"), this.state.sunMeanMotus = _ref[0], this.state.sunMeanMotusPosition = _ref[1];
      if (planet === "mercury" || planet === "venus" || planet === "mars" || planet === "jupiter" || planet === "saturn") {
        this._calculateDeferentAngle();
        this._calculateMeanMotus();
        this._calculateDeferentPosition();
        this._calculateEquantPosition();
        this._calculateParallel();
        this._calculateEpicyclePosition();
        this._calculatePointerAngle();
        this._calculatePointerPoint();
        return this._calculateTruePlace();
      } else if (planet === "sun") {
        this._calculateEquantPosition();
        this._calculateMeanMotus();
        this._calculateParallel();
        this._calculateSunCrossingPoint();
        return this._calculateTruePlace();
      } else if (planet === "moon" || planet === "moon_latitude") {
        this._calculateMeanMotus();
        this._calculateDeferentAngle();
        this._calculateDeferentPosition();
        this._calculateEquantPosition();
        this._calculateEpicyclePosition();
        this._calculatePointerAngle();
        this._calculatePointerPoint();
        this._calculateTruePlace();
        return this._calculateMoonEquations();
      }
    };

    EquatorieSystem.prototype.reset = function() {
      return this.state = {
        meanMotus: 0,
        sunMeanMotus: 0,
        meanMotusPosition: 0,
        sunMeanMotusPosition: 0,
        deferentAngle: 0,
        deferentPosition: 0,
        mercuryDeferentAngle: 0,
        sunCirclePoint: 0,
        passed: 0,
        planet: '',
        date: 0,
        parallelPosition: 0,
        pointerAngle: 0,
        pointerPoint: 0,
        equantPosition: 0,
        epicycleRotation: 0,
        epicyclePosition: 0,
        epicyclePrePosition: 0,
        basePosition: 0,
        truePlace: 0,
        meanAux: 0,
        mercuryDeferentPosition: 0,
        moonEquationCentre: 0,
        moonTrueMotus: 0,
        caputDraconisMotus: 0,
        moonLatitudeDegree: 0,
        moonLatitudeLeft: 0,
        moonLatitudeRight: 0,
        moonLatitudeCentre: 0
      };
    };

    EquatorieSystem.prototype._setPlanet = function(planet) {
      this.state.planet = planet;
      return this;
    };

    EquatorieSystem.prototype._calculateDate = function(date) {
      var a, d, j, m, p, preg, y;
      preg = false;
      if (date.getFullYear() < 1582) {
        preg = true;
      } else if (date.getFullYear() === 1582) {
        if ((date.getMonth() + 1) < 10) {
          preg = true;
        } else if ((date.getMonth() + 1) === 10 && date.getDate() < 15) {
          preg = true;
        }
      }
      a = date.getMonth() === 0 || date.getMonth() === 1 ? 1 : 0;
      y = date.getFullYear() + 4800 - a;
      m = (date.getMonth() + 1) + (12 * a) - 3;
      d = date.getDate();
      if (preg === true) {
        j = d + Math.floor((153 * m + 2) / 5) + (365 * y) + Math.floor(y / 4) - 32045 - 38;
      } else {
        j = d + Math.floor((153 * m + 2) / 5) + (365 * y) + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
      }
      p = j - this.epoch_julian;
      this.state.date = j;
      this.state.passed = p;
      return p;
    };

    EquatorieSystem.prototype._calculateDeferentAngle = function() {
      var angle, _ref, _ref1;
      if ((_ref = this.state.planet) === 'mars' || _ref === 'venus' || _ref === 'jupiter' || _ref === 'saturn' || _ref === 'mercury') {
        angle = -this.planet_data[this.state.planet].apogee_longitude - (this.precession * this.state.passed);
        this.state.deferentAngle = angle;
        return angle;
      } else if ((_ref1 = this.state.planet) === "moon" || _ref1 === "moon_latitude") {
        this.state.deferentAngle = this.state.meanMotus + Math.abs(this.state.meanMotus - this.state.sunMeanMotus);
        return this.state.deferentAngle;
      }
      return this;
    };

    EquatorieSystem.prototype._calculateDeferentPosition = function() {
      var base_position, cr, da, l, md, meanCentre, offset, sr, x, xa, y, _ref, _ref1;
      if ((_ref = this.state.planet) === 'mars' || _ref === 'venus' || _ref === 'jupiter' || _ref === 'saturn') {
        x = this.inch_to_base * 34 * this.planet_data[this.state.planet].deferent_eccentricity * Math.cos(CoffeeGL.degToRad(this.state.deferentAngle));
        y = this.inch_to_base * 34 * this.planet_data[this.state.planet].deferent_eccentricity * Math.sin(CoffeeGL.degToRad(this.state.deferentAngle));
        this.state.deferentPosition = new CoffeeGL.Vec2(x, y);
        cr = Math.cos(CoffeeGL.degToRad(this.state.deferentAngle));
        sr = Math.sin(CoffeeGL.degToRad(this.state.deferentAngle));
        this.state.basePosition = new CoffeeGL.Vec2(this.base_radius * cr, this.base_radius * sr);
        return this.state.deferentPosition;
      } else if (this.state.planet === "mercury") {
        x = this.inch_to_base * 34 * this.planet_data[this.state.planet].deferent_eccentricity * Math.cos(CoffeeGL.degToRad(this.state.deferentAngle));
        y = this.inch_to_base * 34 * this.planet_data[this.state.planet].deferent_eccentricity * Math.sin(CoffeeGL.degToRad(this.state.deferentAngle));
        this.state.deferentPosition = new CoffeeGL.Vec2(x, y);
        meanCentre = Math.abs(this.state.deferentAngle - this.state.meanMotus);
        l = this.state.deferentPosition.length();
        x = Math.cos(CoffeeGL.degToRad(-this.state.meanMotus));
        y = Math.sin(CoffeeGL.degToRad(-this.state.meanMotus));
        offset = new CoffeeGL.Vec2(x, y);
        offset.normalize();
        offset.multScalar(l);
        this.state.mercuryDeferentPosition = this.state.deferentPosition.copy();
        this.state.mercuryDeferentPosition.multScalar(2);
        this.state.mercuryDeferentPosition.add(offset);
        md = CoffeeGL.Vec2.normalize(this.state.mercuryDeferentPosition);
        xa = new CoffeeGL.Vec2(1, 0);
        da = CoffeeGL.radToDeg(Math.acos(md.dot(xa)));
        if (da < 0) {
          da = 360 + da;
        }
        this.state.mercuryDeferentAngle = da;
        cr = Math.cos(CoffeeGL.degToRad(da));
        sr = Math.sin(CoffeeGL.degToRad(da));
        base_position = new CoffeeGL.Vec2(this.base_radius * cr, this.base_radius * sr);
        this.state.basePosition = base_position;
        return this.state.mercuryDeferentPosition;
      } else if ((_ref1 = this.state.planet) === "moon" || _ref1 === "moon_latitude") {
        cr = Math.cos(CoffeeGL.degToRad(this.state.deferentAngle));
        sr = Math.sin(CoffeeGL.degToRad(this.state.deferentAngle));
        x = this.moon_radius * cr;
        y = this.moon_radius * sr;
        this.state.deferentPosition = new CoffeeGL.Vec2(x, y);
        this.state.basePosition = new CoffeeGL.Vec2(this.base_radius * cr, this.base_radius * sr);
      }
      return this;
    };

    EquatorieSystem.prototype._calculateEquantPosition = function() {
      var l, tm, x, y, _ref, _ref1;
      if ((_ref = this.state.planet) === 'mars' || _ref === 'venus' || _ref === 'jupiter' || _ref === 'saturn') {
        this.state.equantPosition = new CoffeeGL.Vec2(this.state.deferentPosition.x * 2, this.state.deferentPosition.y * 2);
        return this.state.equantPosition;
      } else if (this.state.planet === "mercury") {
        x = this.inch_to_base * 34 * this.planet_data[this.state.planet].deferent_eccentricity * Math.cos(CoffeeGL.degToRad(this.state.deferentAngle));
        y = this.inch_to_base * 34 * this.planet_data[this.state.planet].deferent_eccentricity * Math.sin(CoffeeGL.degToRad(this.state.deferentAngle));
        this.state.equantPosition = new CoffeeGL.Vec2(x, y);
      } else if ((_ref1 = this.state.planet) === "moon" || _ref1 === "moon_latitude") {
        tm = new CoffeeGL.Matrix2([-1, 0, 0, -1]);
        this.state.equantPosition = new CoffeeGL.Vec2(this.state.deferentPosition.x, this.state.deferentPosition.y);
        tm.multVec(this.state.equantPosition);
      } else if (this.state.planet === "sun") {
        l = this.inch_to_base * 34 * this.planet_data["sun"].equant_ratio;
        x = Math.cos(CoffeeGL.degToRad(-this.planet_data["sun"].apogee_longitude));
        y = Math.sin(CoffeeGL.degToRad(-this.planet_data["sun"].apogee_longitude));
        this.state.equantPosition = new CoffeeGL.Vec2(x, y);
        this.state.equantPosition.multScalar(l);
      }
      return this;
    };

    EquatorieSystem.prototype._calculateMeanMotusBody = function(body) {
      var mean_motus_angle, mean_motus_position, passed;
      passed = this.state.passed;
      mean_motus_angle = (this.planet_data[body].mean_longitude + (this.planet_data[body].deferent_speed * passed)) % 360 * -1;
      mean_motus_position = new CoffeeGL.Vec2(this.base_radius * Math.cos(CoffeeGL.degToRad(mean_motus_angle)), this.base_radius * Math.sin(CoffeeGL.degToRad(mean_motus_angle)));
      return [mean_motus_angle, mean_motus_position];
    };

    EquatorieSystem.prototype._calculateMeanMotus = function() {
      var mean_motus_angle, mean_motus_position, _ref;
      _ref = this._calculateMeanMotusBody(this.state.planet), mean_motus_angle = _ref[0], mean_motus_position = _ref[1];
      this.state.meanMotusPosition = mean_motus_position;
      return this.state.meanMotus = mean_motus_angle;
    };

    EquatorieSystem.prototype.rayCircleIntersection = function(ray_start, ray_dir, circle_centre, circle_radius) {
      var a, b, c, d2, discriminant, f, r, t, t1, t2, v;
      f = CoffeeGL.Vec2.sub(ray_start, circle_centre);
      r = circle_radius;
      a = ray_dir.dot(ray_dir);
      b = 2 * f.dot(ray_dir);
      c = f.dot(f) - r * r;
      v = new CoffeeGL.Vec2();
      discriminant = b * b - 4 * a * c;
      if (discriminant !== 0) {
        discriminant = Math.sqrt(discriminant);
        t1 = (-b - discriminant) / (2 * a);
        t2 = (-b + discriminant) / (2 * a);
        t = t2;
        if (t2 < 0) {
          t = t1;
        }
        v.copyFrom(ray_start);
        d2 = CoffeeGL.Vec2.multScalar(ray_dir, t);
        v.add(d2);
      }
      return v;
    };

    EquatorieSystem.prototype._calculateParallel = function() {
      var deferent_position, dir, equant_position, passed;
      passed = this.state.passed;
      deferent_position = this.state.deferentPosition;
      if (this.state.planet === "mercury") {
        deferent_position = this.state.mercuryDeferentPosition;
      }
      if (this.state.planet === "sun") {
        deferent_position = this.state.equantPosition;
      }
      equant_position = this.state.equantPosition;
      dir = this.state.meanMotusPosition.copy();
      dir.normalize();
      this.state.parallelPosition = this.rayCircleIntersection(equant_position, dir, deferent_position, this.base_radius);
      return this.state.parallelPosition;
    };

    EquatorieSystem.prototype._calculateSunCrossingPoint = function() {
      var dir;
      dir = CoffeeGL.Vec2.sub(this.state.parallelPosition, this.state.equantPosition);
      dir.normalize();
      this.state.sunCirclePoint = this.rayCircleIntersection(this.state.equantPosition, dir, this.state.equantPosition, 32 * this.inch_to_base);
      return this;
    };

    EquatorieSystem.prototype._calculateMoonEquations = function() {
      var a, b, e, l, p, s, sign, x, x2, y, y2;
      a = CoffeeGL.Vec2.sub(this.state.epicyclePosition, this.state.equantPosition);
      a.normalize();
      b = this.state.epicyclePosition.copy().normalize().multScalar(-1);
      this.state.moonEquationCentre = CoffeeGL.radToDeg(Math.acos(a.dot(b)));
      this.state.moonTrueMotus = this.state.meanMotus + this.state.moonEquationCentre;
      this.state.caputDraconisMotus = (this.planet_data["caput_draconis"].start_motus + (this.state.passed * this.planet_data["caput_draconis"].speed)) % 360;
      p = this.state.truePlace;
      l = p - this.state.caputDraconisMotus;
      if (l > 360) {
        l = 360 - l;
      }
      if (l < 0) {
        l = 360 + l;
      }
      sign = 1;
      if (l > 180) {
        l = l - 180;
        sign = -1;
      }
      this.state.moonLatitudeDegree = l;
      x = Math.cos(CoffeeGL.degToRad(-this.state.moonLatitudeDegree));
      y = Math.sin(CoffeeGL.degToRad(-this.state.moonLatitudeDegree));
      this.state.moonLatitudeFinal = y * -5 * sign;
      s = new CoffeeGL.Vec2(x, y);
      s.multScalar(this.base_radius - this.epicycle_thickness);
      x2 = Math.cos(CoffeeGL.degToRad(this.state.moonLatitudeDegree - 180));
      y2 = Math.sin(CoffeeGL.degToRad(this.state.moonLatitudeDegree - 180));
      e = new CoffeeGL.Vec2(x2, y2);
      e.multScalar(this.base_radius - this.epicycle_thickness);
      this.state.moonLatitudeLeft = s;
      this.state.moonLatitudeRight = e;
      this.state.moonLatitudeCentre = new CoffeeGL.Vec2(0, s.y);
      return this;
    };

    EquatorieSystem.prototype._calculateEpicyclePosition = function() {
      var dangle, deferent_position, edir, equant_position, f0, f1, fangle, l, passed, _ref, _ref1;
      passed = this.state.passed;
      dangle = this.state.deferentAngle;
      if (this.state.planet === "mercury") {
        dangle = this.state.mercuryDeferentAngle;
      }
      deferent_position = this.state.deferentPosition;
      if (this.state.planet === "mercury") {
        deferent_position = this.state.mercuryDeferentPosition;
      }
      equant_position = this.state.equantPosition;
      l = deferent_position.length() + this.epicycle_radius - this.epicycle_thickness;
      this.state.epicyclePrePosition = CoffeeGL.Vec2.normalize(deferent_position).multScalar(l);
      fangle = 0;
      if ((_ref = this.state.planet) === "mercury" || _ref === "venus" || _ref === "mars" || _ref === "jupiter" || _ref === "saturn") {
        edir = CoffeeGL.Vec2.sub(this.state.parallelPosition, this.state.equantPosition);
        edir.normalize();
        this.state.epicyclePosition = this.rayCircleIntersection(this.state.equantPosition, edir, this.state.deferentPosition, this.base_radius - this.epicycle_thickness);
        f0 = CoffeeGL.radToDeg(Math.atan2(this.state.basePosition.y - deferent_position.y, this.state.basePosition.x - deferent_position.x));
        f1 = CoffeeGL.radToDeg(Math.atan2(this.state.epicyclePosition.y - deferent_position.y, this.state.epicyclePosition.x - deferent_position.x));
        fangle = f0 - f1;
        this.state.epicycleRotation = fangle;
        return this.state.epicyclePosition;
      } else if ((_ref1 = this.state.planet) === "moon" || _ref1 === "moon_latitude") {
        edir = this.state.meanMotusPosition.copy();
        edir.normalize();
        this.state.epicyclePosition = this.rayCircleIntersection(new CoffeeGL.Vec2(0, 0), edir, this.state.deferentPosition, this.base_radius - this.epicycle_thickness);
        f0 = CoffeeGL.radToDeg(Math.atan2(this.state.basePosition.y - deferent_position.y, this.state.basePosition.x - deferent_position.x));
        f1 = CoffeeGL.radToDeg(Math.atan2(this.state.epicyclePosition.y - deferent_position.y, this.state.epicyclePosition.x - deferent_position.x));
        fangle = f0 - f1;
        this.state.epicycleRotation = fangle;
        return this.state.epicyclePosition;
      }
    };

    EquatorieSystem.prototype._calculatePointerAngle = function() {
      var a, angle, b, c, deferent_position, determinate, passed, sa, sb, va, vb, _ref, _ref1;
      passed = this.state.passed;
      angle = (this.planet_data[this.state.planet].mean_anomaly + (this.planet_data[this.state.planet].epicycle_speed * passed)) % 360 * -1;
      if ((_ref = this.state.planet) === "mercury" || _ref === "venus" || _ref === "mars" || _ref === "jupiter" || _ref === "saturn") {
        deferent_position = this.state.deferentPosition;
        if (this.state.planet === "mercury") {
          deferent_position = this.state.mercuryDeferentPosition;
        }
        a = this.state.equantPosition.dist(this.state.epicyclePosition);
        b = deferent_position.dist(this.state.epicyclePosition);
        c = this.state.equantPosition.dist(deferent_position);
        va = CoffeeGL.Vec2.sub(this.state.epicyclePosition, this.state.equantPosition);
        vb = CoffeeGL.Vec2.sub(this.state.epicyclePosition, deferent_position);
        va.normalize();
        vb.normalize();
        determinate = va.x * vb.y - va.y * vb.x;
        sa = CoffeeGL.radToDeg(Math.acos((a * a + b * b - c * c) / (2 * a * b)));
        this.state.meanAux = 90 - sa;
        if (determinate > 0) {
          this.state.meanAux = 90 + sa;
        }
        this.state.pointerAngle = -angle;
      } else if ((_ref1 = this.state.planet) === "moon" || _ref1 === "moon_latitude") {
        a = this.state.epicyclePosition.length();
        b = this.state.equantPosition.dist(this.state.epicyclePosition);
        c = this.state.equantPosition.length();
        sa = CoffeeGL.radToDeg(Math.acos((a * a + b * b - c * c) / (2 * a * b)));
        a = this.state.epicyclePosition.length();
        b = this.state.deferentPosition.dist(this.state.epicyclePosition);
        c = this.state.deferentPosition.length();
        sb = CoffeeGL.radToDeg(Math.acos((a * a + b * b - c * c) / (2 * a * b)));
        this.state.meanAux = 90 - sa - sb;
        va = this.state.epicyclePosition.copy();
        va.multScalar(-1);
        vb = CoffeeGL.Vec2.sub(this.state.epicyclePosition, this.state.equantPosition);
        va.normalize();
        vb.normalize();
        determinate = va.x * vb.y - va.y * vb.x;
        if (determinate > 0) {
          this.state.meanAux = 90 + sa + sb;
        }
        this.state.pointerAngle = angle;
      }
      return angle;
    };

    EquatorieSystem.prototype._calculatePointerPoint = function() {
      var angle, ca, deferent_position, dir, epipos, perp, sa;
      angle = this.state.pointerAngle + this.state.meanAux;
      epipos = this.state.epicyclePosition;
      deferent_position = this.state.deferentPosition;
      if (this.state.planet === "mercury") {
        deferent_position = this.state.mercuryDeferentPosition;
      }
      dir = CoffeeGL.Vec2.normalize(CoffeeGL.Vec2.sub(this.state.epicyclePosition, deferent_position));
      perp = dir.copy();
      perp.x = -dir.y;
      perp.y = dir.x;
      perp.multScalar(this.base_radius * this.planet_data[this.state.planet].epicycle_ratio);
      ca = Math.cos(CoffeeGL.degToRad(-angle));
      sa = Math.sin(CoffeeGL.degToRad(-angle));
      perp = new CoffeeGL.Vec2(perp.x * ca - perp.y * sa, perp.x * sa + perp.y * ca);
      perp.add(this.state.epicyclePosition);
      this.state.pointerPoint = perp;
      return perp;
    };

    EquatorieSystem.prototype._calculateTruePlace = function() {
      var angle, determinate, dir, pp, xaxis, _ref;
      if ((_ref = this.state.planet) === "mercury" || _ref === "venus" || _ref === "mars" || _ref === "jupiter" || _ref === "saturn" || _ref === "moon" || _ref === "moon_latitude") {
        pp = this.state.pointerPoint;
        dir = CoffeeGL.Vec2.normalize(pp);
        xaxis = new CoffeeGL.Vec2(1, 0);
        angle = CoffeeGL.radToDeg(Math.acos(xaxis.dot(dir)));
        if (pp.y > 0) {
          angle = 360 - angle;
        }
        return this.state.truePlace = angle;
      } else if (this.state.planet === "sun") {
        xaxis = new CoffeeGL.Vec2(1, 0);
        angle = CoffeeGL.radToDeg(Math.acos(xaxis.dot(CoffeeGL.Vec2.normalize(this.state.sunCirclePoint))));
        determinate = this.state.sunCirclePoint.y;
        if (determinate > 0) {
          return this.state.truePlace = 360 - angle;
        } else {
          return this.state.truePlace = angle;
        }
      }
    };

    return EquatorieSystem;

  })();

  module.exports = {
    EquatorieSystem: EquatorieSystem
  };

}).call(this);
